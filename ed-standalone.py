#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('cone_sorting.py', b'from itertools import zip_longest\nfrom typing import Optional\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport plotly.graph_objects as go\nimport streamlit as st\nfrom chabo_common.constants.cone_types import ConeTypes\nfrom chabo_common.utils.math_utils import angle_from_2d_vector, rotate\nfrom common import (\n    CONE_TYPE_TO_COLOR,\n    create_animation,\n    get_cones_for_configuration,\n    visualize_configuration,\n)\nfrom matplotlib.axes import Axes\nfrom matplotlib.patches import Polygon\nfrom traitlets import Bool\n\nfrom chabo_pathing.sorting_cones.trace_sorter.adjacency_matrix import (\n    create_adjacency_matrix,\n)\nfrom chabo_pathing.sorting_cones.trace_sorter.core_trace_sorter import TraceSorter\nfrom chabo_pathing.sorting_cones.trace_sorter.cost_function import cost_configurations\nfrom chabo_pathing.sorting_cones.trace_sorter.end_configurations import (\n    find_all_end_configurations,\n)\nfrom chabo_pathing.types import BoolArray, FloatArray, IntArray\n\n\ndef get_points_on_ellipse(thetas: FloatArray, a: float, b: float) -> np.ndarray:\n    x = a * np.cos(thetas)\n    y = b * np.sin(thetas)\n    return np.column_stack([x, y])\n\n\ndef show_starting_cone(\n    position: FloatArray,\n    direction: FloatArray,\n    cones_by_type: FloatArray,\n    max_distance: float,\n) -> list[Optional[int]]:\n    fig, ax = visualize_configuration(\n        position,\n        direction,\n        cones_by_type,\n        with_cone_index=False,\n        with_lines=False,\n        do_show=False,\n    )\n\n    fov_points = get_points_on_ellipse(\n        np.arange(0, 2 * np.pi, 0.01),\n        max_distance * 1.3,\n        max_distance / 1.3,\n    )\n\n    angle_direction = float(angle_from_2d_vector(direction))\n    final_fov_points = rotate(fov_points, angle_direction) + position\n\n    poly = Polygon(final_fov_points, closed=True, fill=True, facecolor="red", alpha=0.3)\n\n    sorter = TraceSorter(\n        3,\n        3,\n        max_dist_to_first=max_distance,\n        max_length=10,\n        threshold_absolute_angle=0,\n        threshold_directional_angle=0.5,\n    )\n    out: list[Optional[int]] = [None for _ in ConeTypes]\n    for cone_type in (ConeTypes.LEFT, ConeTypes.RIGHT):\n        cones = cones_by_type[cone_type]\n        car_to_cone = cones - position\n        angle_to_car = angle_from_2d_vector(rotate(car_to_cone, -angle_direction))\n\n        distance_to_car = np.linalg.norm(car_to_cone, axis=1)\n        idx = sorter.select_starting_cone(\n            position, direction, cones, angle_to_car, distance_to_car\n        )\n        if idx is None:\n            st.warning(f"No starting cone found for {cone_type}")\n        else:\n            ax.plot(cones[idx, 0], cones[idx, 1], "x", color="black")\n\n        out[cone_type] = idx\n\n    ax.add_patch(poly)\n\n    st.pyplot(fig)  # type: ignore\n\n    return out\n\n\ndef plot_adjacency_matrix(\n    adjacency_matrix: BoolArray, cones: FloatArray, ax: Axes\n) -> None:\n\n    ax.axis("equal")\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    ax.plot(*cones.T, ".k")\n    for cone, adj_mask in zip(cones, adjacency_matrix):\n        for is_neighbor, neighbor in zip(adj_mask, cones):\n            if is_neighbor:\n                ax.plot(*np.array([cone, neighbor]).T, "-k", alpha=0.2)\n\n\ndef show_adjacency_matrix(\n    cones_by_type: list[FloatArray],\n    start_indices: list[Optional[int]],\n    n_neighbors: int,\n    max_distance: float,\n) -> list[Optional[BoolArray]]:\n    show_two_plots = st.checkbox("Show each side in a separate plot")\n\n    adjacency_matrices: list[Optional[BoolArray]] = [None for _ in ConeTypes]\n\n    fig, ax = plt.subplots(1, 2 if show_two_plots else 1)\n    for i, cone_type in enumerate((ConeTypes.LEFT, ConeTypes.RIGHT)):\n        cones = cones_by_type[cone_type]\n        start_idx = start_indices[cone_type]\n        adjacency_matrix, reachable_nodes = create_adjacency_matrix(\n            cones, n_neighbors, start_idx, max_distance\n        )\n        adjacency_matrices[cone_type] = adjacency_matrix\n\n        ax_to_use = ax[i] if show_two_plots else ax\n        plot_adjacency_matrix(adjacency_matrix, cones, ax_to_use)\n\n    st.pyplot(fig)  # type: ignore\n\n    return adjacency_matrices\n\n\ndef show_graph_search(\n    cones_by_type: list[FloatArray],\n    adjacency_matrices: list[Optional[BoolArray]],\n    start_indices: list[Optional[int]],\n    target_length: int,\n    threshold_directional_angle: float,\n    threshold_absolute_angle: float,\n) -> list[Optional[IntArray]]:\n\n    cols = st.columns(2)\n    all_end_configs: list[Optional[IntArray]] = [None for _ in ConeTypes]\n    for cone_type, col in zip((ConeTypes.LEFT, ConeTypes.RIGHT), cols):\n\n        cones = cones_by_type[cone_type]\n\n        adjacency_matrix = adjacency_matrices[cone_type]\n        start_idx = start_indices[cone_type]\n        end_configurations, (\n            all_configurations,\n            configuration_is_end,\n        ) = find_all_end_configurations(\n            cones,\n            cone_type,\n            start_idx,\n            adjacency_matrix,\n            target_length,\n            threshold_directional_angle,\n            threshold_absolute_angle,\n            np.zeros(0, dtype=np.int32),\n            store_all_end_configurations=True,\n        )\n\n        all_end_configs[cone_type] = end_configurations\n\n        frames = []\n        for config, is_end_configuration in zip(\n            all_configurations, configuration_is_end\n        ):\n\n            config = config[config != -1]\n            points = cones[config]\n            scatter_lines = go.Scatter(\n                x=points[:, 0],\n                y=points[:, 1],\n                mode="lines+text",\n                marker_color="black" if is_end_configuration else "red",\n                line_dash="solid" if is_end_configuration else "dash",\n                text=list(range(1, len(points) + 1)),\n            )\n            scatter_cones = go.Scatter(\n                x=cones[:, 0],\n                y=cones[:, 1],\n                mode="markers",\n            )\n            frame = go.Frame(\n                data=[\n                    scatter_cones,\n                    scatter_lines,\n                ]\n            )\n            frames.append(frame)\n\n        xm = np.min(cones[:, 0]) - 1\n        xM = np.max(cones[:, 0]) + 1\n        ym = np.min(cones[:, 1]) - 1\n        yM = np.max(cones[:, 1]) + 1\n\n        fig = create_animation(frames)\n        fig.update_layout(\n            title_text=f"{cone_type.name} configurations",\n            plot_bgcolor="white",\n            xaxis=dict(range=[xm, xM], autorange=False, showticklabels=False),\n            yaxis=dict(\n                range=[ym, yM],\n                autorange=False,\n                scaleanchor="x",\n                scaleratio=1,\n                showticklabels=False,\n            ),\n            showlegend=False,\n        )\n\n        fig.update_traces(textposition="top left")\n\n        with col:\n            st.plotly_chart(\n                fig,\n                config={"displayModeBar": False},\n                use_container_width=True,\n            )\n\n    return all_end_configs\n\n\ndef show_costs(\n    cones_by_type: list[Optional[FloatArray]],\n    end_configurations_by_type: list[Optional[IntArray]],\n    direction: FloatArray,\n) -> list[FloatArray]:\n    final_out = [np.zeros((0, 2)) for _ in ConeTypes]\n    for cone_type in (ConeTypes.LEFT, ConeTypes.RIGHT):\n\n        cones = cones_by_type[cone_type]\n        end_configurations = end_configurations_by_type[cone_type]\n        assert cones is not None\n        assert end_configurations is not None\n\n        costs = cost_configurations(\n            cones,\n            end_configurations,\n            cone_type,\n            direction,\n            return_individual_costs=True,\n        )\n\n        n_configurations = len(end_configurations)\n        n_cols = min(n_configurations, 4)\n        n_rows = int(np.ceil(n_configurations / n_cols))\n        fig, axes = plt.subplots(n_rows, n_cols, figsize=(n_cols * 4, n_rows * 4))\n\n        if not isinstance(axes, np.ndarray):\n            axes = np.array([axes])\n\n        names = [\n            "Mean angle",\n            "Intersection",\n            "Distance",\n            "#Cones",\n            "Direction",\n            "Total",\n        ]\n\n        idx_sort_cost = costs.sum(axis=1).argsort()\n\n        border = 1.5\n        mx, Mx = np.min(cones[:, 0]) - border, np.max(cones[:, 0]) + border\n        my, My = np.min(cones[:, 1]) - border, np.max(cones[:, 1]) + border\n\n        sm, sM = max([(mx, Mx), (my, My)], key=lambda x: x[1] - x[0])\n\n        best_config = end_configurations[idx_sort_cost[0]]\n        final_out[cone_type] = cones[best_config[best_config != -1]]\n\n        for config_costs, configuration, ax in zip_longest(\n            costs[idx_sort_cost], end_configurations[idx_sort_cost], axes.flatten()\n        ):\n            if config_costs is not None and configuration is not None:\n                configuration = configuration[configuration != -1]\n                ax.plot(\n                    *cones[configuration].T, "o-", color=CONE_TYPE_TO_COLOR[cone_type]\n                )\n\n                all_costs_config = [*config_costs, config_costs.sum()]\n                ax.set_title(\n                    "\\n".join(\n                        f"{name}: {value:.3f}"\n                        for name, value in zip(names, all_costs_config)\n                    )\n                )\n                text_offset = 0.5\n                for i, (x, y) in enumerate(cones[configuration], start=1):\n                    ax.text(x - text_offset, y - text_offset, str(i))\n\n                ax.set_xlim(sm, sM)\n                ax.set_ylim(sm, sM)\n                ax.set_aspect("equal")\n            else:\n                ax.spines["top"].set_visible(False)\n                ax.spines["right"].set_visible(False)\n                ax.spines["bottom"].set_visible(False)\n                ax.spines["left"].set_visible(False)\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        fig.tight_layout()\n\n        with st.expander(f"{cone_type.name} costs"):\n            st.pyplot(fig)  # type: ignore\n\n    return final_out\n\n\ndef run() -> None:\n    st.markdown(\n        """\n# Cone Sorting\n\nCone sorting is the process of sorting a set of cones into a sequence of cones. The goal\nof this process is to put the SLAM cones in the order of the track direction.\n\nLeft and right sides are sorted independently from each other.\n\nThe sorting algorithm runs on only a subset of all available cones. The only cones within\na specific range from the vehicle pose are considered. This is done to reduce computation\ntime.\n\nLike the rest of the algorithms, the sorting algorithm has been designed to be completely\nstateless.\n\nFor each side the algorithm the following steps are performed:\n\nThe core cone sorting algorithm has the following steps:\n\n- Pick a starting cone\n- Construct graph of consecutive cones\n- Apply graph search to find all possible configurations\n- Calculate the cost of each configuration\n- Select the configuration with the lowest cost\n"""\n    )\n\n    st.markdown(\n        """\n## Inputs\n\nIn the bellow graph you can see the input for our algorithm. The inputs are:\n- The vehicle pose\n- The cones close to the vehicle\n\nOur goal is that after the algorithm is finished, the cones are sorted in the order of the\ntrack direction. We will be able to verify based on the index of each cone in the final\nresult.\n"""\n    )\n    position, direction, cones_by_type = get_cones_for_configuration(\n        st.session_state.track_configuration\n    )\n\n    show_lines = st.checkbox("Show lines", help="Show lines between consecutive cones")\n    visualize_configuration(\n        position,\n        direction,\n        cones_by_type,\n        with_cone_index=True,\n        with_lines=show_lines,\n        do_show=True,\n    )\n\n    st.markdown(\n        """\n    ## Picking a starting cone\n\n    Our goal is to apply a graph search to find all possible configurations. For this we need\n    to know the starting cone. The starting cone is picked as the one closest to the vehicle\n    that is in front of the vehicle.\n\n    ### Parameters\n\n    - **Maximum distance**: The maximum distance for a cone to be considered a starting cone.\n    We do not use the maximum distance directly, but we use it as the basis for the radii\n    of an ellipse where the major axis is $1.3$ times the maximum distance and the minor axis is\n    $1.3^{-1}$ times the maximum distance.\n    """\n    )\n\n    maximum_distance = st.slider(\n        "Maximum distance",\n        4.0,\n        10.0,\n        help="Maximum distance for a cone to be considered a starting cone",\n    )\n\n    start_indices = show_starting_cone(\n        position, direction, cones_by_type, maximum_distance\n    )\n\n    st.markdown(\n        """\n## Graph construction\n\nNow that we know what our starting cone is, we can construct the graph. The main assumption\nthat we make when constructing the graph that we make is that cones that are far away from \neach other should not be connected. Intuitively, we can say that if two cones are, e.g. 20m apart,\nthen the likelihood of them being connected is very low.\n\n### Parameters\n- **Maximum number of neighbors**: The maximum number of neighbors that a cone can have.\n- **Maximum distance**: The maximum distance for a cone to be considered a neighbor.\n"""\n    )\n    col_neighbors, col_distance = st.columns(2)\n    with col_neighbors:\n        n_neighbors = st.slider(\n            "Max number of neighbors", 2, 5, 3, step=1, help="Max number of neighbors"\n        )\n    with col_distance:\n        maximum_distance = st.slider(\n            "Max distance between neighbors",\n            2.0,\n            10.0,\n            5.0,\n            step=0.2,\n            help="Max distance between neighbors",\n        )\n    adjacency_matrices = show_adjacency_matrix(\n        cones_by_type, start_indices, n_neighbors, maximum_distance\n    )\n    st.markdown(\n        """\n## Graph search\n\nAfter constructing the graph, we can now apply a graph search to find all possible configurations.\nWe apply depth first search to find all possible configurations, however the type of search\nis not important.\n\n### Parameters\n- **Maximum depth**: The maximum depth of the graph search. The depth is the number of cones that can be visited before the search is stopped.\n- **Directional angle threshold**: When sorting the cones, rotating to one side is more complicated. When sorting yellow cones (which are on the right side) rotating clockwise is more risky, since we might connect cones that should not be connected. To address this we add this parameter which limits the angle maximum angle in the direction (clockwise for yellow cones, counterclockwise for blue cones).\n"""\n    )\n\n    maximum_depth = st.slider(\n        "Maximum depth",\n        3,\n        15,\n        5,\n        step=1,\n        help="Maximum depth of the graph search",\n    )\n    threshold_directional_angle = np.deg2rad(\n        st.slider("Threshold directional angle", 20, 90, 40, step=1)\n    )\n    threshold_absolute_angle = np.deg2rad(\n        st.slider("Threshold absolute angle", 20, 90, 70, step=1)\n    )\n\n    end_configurations_by_type = show_graph_search(\n        cones_by_type,\n        adjacency_matrices,\n        start_indices,\n        maximum_depth,\n        threshold_directional_angle,\n        threshold_absolute_angle,\n    )\n\n    st.markdown(\n        """\n## Cost calculation\n\nNow that we have all the candidates, we need to calculate the cost of each configuration.\nThe cost configuration is consists of the following:\n- Mean angle between consecutive cones\n- Number of edge intersections ($2^{\\#=intersections}-1$)\n- Sum of edge distances\n- Number of nodes (cones) in the configuration (more nodes are preferred) ($1/{\\#nodes}$)\n\nThe final cost function is a weighted sum of the above cost functions.\n"""\n    )\n    sorted_cones_by_type = show_costs(\n        cones_by_type, end_configurations_by_type, direction\n    )\n\n    st.markdown(\n        """\n## Result\n\nFinally we can visualize the final output of the algorithm.\n"""\n    )\n\n    visualize_configuration(\n        position,\n        direction,\n        sorted_cones_by_type,\n        with_cone_index=True,\n        with_lines=True,\n        do_show=True,\n    )\n')
    __stickytape_write_module('chabo_common/__init__.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: Other code can import common objects from here.\n\nProject: FaSTTUBe Chabo Common\n"""\n# pylint: disable=useless-import-alias\n# we use import X as X because mypy does not allow implicit reexports in strict mode\n# we import everything other than visualization stuff\n# from chabo_common.constants.as_state import ASState as ASState\n# from chabo_common.constants.car_type import CarType as CarType\nfrom .constants.cone_types import ConeTypes as ConeTypes\n\n# from chabo_common.constants.mission_types import MissionTypes as MissionTypes\n# from chabo_common.utils.math_utils import angle_from_2d_vector as angle_from_2d_vector\n# from chabo_common.utils.math_utils import (\n#     calc_pairwise_distances as calc_pairwise_distances,\n# )\n# from chabo_common.utils.math_utils import lerp as lerp\n# from chabo_common.utils.math_utils import (\n#     linearly_combine_values_over_time as linearly_combine_values_over_time,\n# )\n# from chabo_common.utils.math_utils import my_cdist_sq_euclidean as my_cdist_sq_euclidean\n# from chabo_common.utils.math_utils import my_in1d as my_in1d\n# from chabo_common.utils.math_utils import my_njit as my_njit\n# from chabo_common.utils.math_utils import normalize as normalize\n# from chabo_common.utils.math_utils import odd_square as odd_square\n# from chabo_common.utils.math_utils import rotate as rotate\n# from chabo_common.utils.math_utils import trace_angles_between as trace_angles_between\n# from chabo_common.utils.math_utils import (\n#     trace_calculate_consecutive_radii as trace_calculate_consecutive_radii,\n# )\n# from chabo_common.utils.math_utils import (\n#     trace_distance_to_next as trace_distance_to_next,\n# )\n# from chabo_common.utils.math_utils import (\n#     unit_2d_vector_from_angle as unit_2d_vector_from_angle,\n# )\n# from chabo_common.utils.math_utils import vec_angle_between as vec_angle_between\n# from chabo_common.utils.math_utils import vec_dot as vec_dot\n# from chabo_common.utils.spline_fit import SplineEvaluator as SplineEvaluator\n# from chabo_common.utils.spline_fit import SplineFitterFactory as SplineFitterFactory\n# from chabo_common.utils.utils import Timer as Timer\n')
    __stickytape_write_module('chabo_common/constants/cone_types.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: Enum for cone types (yellow, blue, etc...)\n\nTaken directly from ft-as-utils\n\nProject: FaSTTUBe Chabo Common\n"""\nfrom enum import IntEnum\n\n\nclass ConeTypes(IntEnum):\n    """\n    Enum for all possible cone types\n    """\n\n    UNKNOWN = 0\n    YELLOW = 1\n    RIGHT = 1\n    BLUE = 2\n    LEFT = 2\n    ORANGE_SMALL = 3\n    START_FINISH_AREA = 3\n    ORANGE_BIG = 4\n    START_FINISH_LINE = 4\n')
    __stickytape_write_module('chabo_common/utils/math_utils.py', b'#!/usin_roll/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: A module with common mathematical functions\n\nTaken from ft-as-utils\n\nProject: FaSTTUBe Chabo Common\n"""\nfrom typing import Tuple, TypeVar, cast\n\nimport numpy as np\nfrom numba import jit\n\nT = TypeVar("T")\n\n\ndef my_njit(func: T) -> T:\n    """\n    numba.njit is an untyped decorator. This wrapper helps type checkers keep the\n    type information after applying the decorator. Furthermore, it sets some performance\n    flags\n\n    Args:\n        func (T): The function to jit\n\n    Returns:\n        T: The jitted function\n    """\n    jit_func: T = jit(nopython=True, cache=True, nogil=True, fastmath=True)(func)\n\n    return jit_func\n\n\n@my_njit\ndef vec_dot(vecs1: np.ndarray, vecs2: np.ndarray) -> np.ndarray:\n    """\n    Mutliplies vectors in an array elementwise\n\n    Args:\n        vecs1 (np.array): The first "list" of vectors\n        vecs2 (np.array): The second "list" of vectors\n\n    Returns:\n        np.array: The results\n    """\n    return np.sum(vecs1 * vecs2, axis=-1)\n\n\n@my_njit\ndef norm_of_last_axis(arr: np.ndarray) -> np.ndarray:\n\n    original_shape = arr.shape\n    arr_row_col = arr.flatten().reshape(-1, arr.shape[-1])\n    result = np.empty(arr_row_col.shape[0])\n    for i in range(arr_row_col.shape[0]):\n        vec = arr_row_col[i]\n        result[i] = np.sqrt(vec_dot(vec, vec))\n\n    result = result.reshape(original_shape[:-1])\n\n    return result\n\n\n@my_njit\ndef vec_angle_between(\n    vecs1: np.ndarray, vecs2: np.ndarray, clip_cos_theta: bool = True\n) -> np.ndarray:\n    """\n    Calculates the angle between the vectors of the last dimension\n\n    Args:\n        vecs1 (np.ndarray): An array of shape (...,2)\n        vecs2 (np.ndarray): An array of shape (...,2)\n        clip_cos_theta (bool): Clip the values of the dot products so that they are\n        between -1 and 1. Defaults to True.\n\n    Returns:\n        np.ndarray: A vector, such that each element i contains the angle between\n        vectors vecs1[i] and vecs2[i]\n    """\n    cos_theta = vec_dot(vecs1, vecs2)\n\n    cos_theta /= norm_of_last_axis(vecs1) * norm_of_last_axis(vecs2)\n\n    cos_theta = np.asarray(cos_theta)\n\n    cos_theta_flat = cos_theta.ravel()\n\n    if clip_cos_theta:\n        cos_theta_flat[cos_theta_flat < -1] = -1\n        cos_theta_flat[cos_theta_flat > 1] = 1\n\n    return np.arccos(cos_theta)\n\n\ndef rotate(points: np.ndarray, theta: float) -> np.ndarray:\n    """\n    Rotates the points in `points` by angle `theta` around the origin\n\n    Args:\n        points (np.array): The points to rotate. Shape (n,2)\n        theta (float): The angle by which to rotate in radians\n\n    Returns:\n        np.array: The points rotated\n    """\n    cos_theta, sin_theta = np.cos(theta), np.sin(theta)\n    rotation_matrix = np.array(((cos_theta, -sin_theta), (sin_theta, cos_theta))).T\n    return np.dot(points, rotation_matrix)\n\n\n@my_njit\ndef my_cdist_sq_euclidean(arr_a: np.ndarray, arr_b: np.ndarray) -> np.ndarray:\n    """\n    Calculates the pairwise square euclidean distances from each point in `X` to each\n    point in `Y`\n\n    Credit:\n        Uses https://stackoverflow.com/a/56084419 which in turn uses\n        https://github.com/droyed/eucl_dist\n\n    Args:\n        arr_a (np.array): A 2d array of shape (m,k)\n        arr_b (np.array): A 2d array of shape (n,k)\n\n    Returns:\n        np.array: A matrix of shape (m,n) containing the square euclidean distance\n        between all the points in `X` and `Y`\n    """\n    n_x, dim = arr_a.shape\n    x_ext = np.empty((n_x, 3 * dim))\n    x_ext[:, :dim] = 1\n    x_ext[:, dim : 2 * dim] = arr_a\n    x_ext[:, 2 * dim :] = np.square(arr_a)\n\n    n_y = arr_b.shape[0]\n    y_ext = np.empty((3 * dim, n_y))\n    y_ext[:dim] = np.square(arr_b).T\n    y_ext[dim : 2 * dim] = -2 * arr_b.T\n    y_ext[2 * dim :] = 1\n\n    return np.dot(x_ext, y_ext)\n\n\n@my_njit\ndef calc_pairwise_distances(\n    points: np.ndarray, dist_to_self: float = 0.0\n) -> np.ndarray:\n    """\n    Given a set of points, creates a distance matrix from each point to every point\n\n    Args:\n        points (np.ndarray): The points for which the distance matrix should be\n        calculated dist_to_self (np.ndarray, optional): The distance to set the\n        diagonal. Defaults to 0.0.\n\n    Returns:\n        np.ndarray: The 2d distance matrix\n    """\n    pairwise_distances = my_cdist_sq_euclidean(points, points)\n\n    if dist_to_self != 0:\n        for i in range(len(points)):\n            pairwise_distances[i, i] = dist_to_self\n    return pairwise_distances\n\n\n@my_njit\ndef my_in1d(test_values: np.ndarray, source_container: np.ndarray) -> np.ndarray:\n    """\n    Calculate a boolean mask for a 1d array indicating if an element in `test_values` is\n    present in `source container` which is also 1d\n\n    Args:\n        test_values (np.ndarray): The values to test if they are inside the container\n        source_container (np.ndarray): The container\n\n    Returns:\n        np.ndarray: A boolean array with the same length as `test_values`. If\n        `return_value[i]` is `True` then `test_value[i]` is in `source_container`\n    """\n    source_sorted = np.sort(source_container)\n    is_in = np.zeros(test_values.shape[0], dtype=np.bool_)\n    for i, test_val in enumerate(test_values):\n        for source_val in source_sorted:\n\n            if test_val == source_val:\n                is_in[i] = True\n                break\n\n            if source_val > test_val:\n                break\n\n    return is_in\n\n\ndef trace_calculate_consecutive_radii(trace: np.ndarray) -> np.ndarray:\n    """\n    Expects a (n,2) array and returns the radius of the circle that passes\n    between all consecutive point triples. The radius between index 0,1,2, then 1,2,3\n    and so on\n\n    Args:\n        trace (np.ndarray): The points for which the radii will be calculated\n\n    Returns:\n        np.ndarray: The radii for each consecutive point triple\n    """\n\n    # TODO: Vectorize this function. Limit is the indexer\n    indexer = np.arange(3)[None, :] + 1 * np.arange(trace.shape[-2] - 2)[:, None]\n\n    points = trace[indexer]\n    radii = calculate_radius_from_points(points)\n    return radii\n\n\ndef trace_distance_to_next(trace: np.ndarray) -> np.ndarray:\n    """\n    Calculates the distance of one point in the trace to the next. Obviously the last\n    point doesn\'t have any distance associated\n\n    Args:\n        trace (np.array): The points of the trace\n\n    Returns:\n        np.array: A vector containing the distances from one point to the next\n    """\n    return np.linalg.norm(np.diff(trace, axis=-2), axis=-1)\n\n\ndef trace_angles_between(trace: np.ndarray) -> np.ndarray:\n    """\n    Calculates the angles in a trace from each point to its next\n\n    Args:\n        trace (np.array): The trace containing a series of 2d vectors\n\n    Returns:\n        np.array: The angle from each vector to its next, with `len(return_value) ==\n        len(trace) - 1`\n    """\n    all_to_next = np.diff(trace, axis=-2)\n    from_middle_to_next = all_to_next[..., 1:, :]\n    from_middle_to_prev = -all_to_next[..., :-1, :]\n    angles = vec_angle_between(from_middle_to_next, from_middle_to_prev)\n    return angles\n\n\n@my_njit\ndef unit_2d_vector_from_angle(rad: np.ndarray) -> np.ndarray:\n    """\n    Creates unit vectors for each value in the rad array\n\n    Args:\n        rad (np.array): The angles (in radians) for which the vectors should be created\n\n    Returns:\n        np.array: The created unit vectors\n    """\n    rad = np.asarray(rad)\n    new_shape = rad.shape + (2,)\n    res = np.empty(new_shape, dtype=rad.dtype)\n    res[..., 0] = np.cos(rad)\n    res[..., 1] = np.sin(rad)\n    return res\n\n\n# Calculates the angle of each vector in `vecs`\n# TODO: Look into fixing return type when a single vector is provided (return float)\ndef angle_from_2d_vector(vecs: np.ndarray) -> np.ndarray:\n    """\n    Calculates the angle of each vector in `vecs`. If `vecs` is just a single 2d vector\n    then one angle is calculated and a scalar is returned\n\n    >>> import numpy as np\n    >>> x = np.array([[1, 0], [1, 1], [0, 1]])\n    >>> angle_from_2d_vector(x)\n    >>> array([0.        , 0.78539816, 1.57079633])\n\n    Args:\n        vecs (np.array): The vectors for which the angle is calculated\n\n    Raises:\n        ValueError: If `vecs` has the wrong shape a ValueError is raised\n\n    Returns:\n        np.array: The angle of each vector in `vecs`\n    """\n    if vecs.shape == (2,):\n        return np.arctan2(vecs[1], vecs[0])\n    if vecs.ndim == 2 and vecs.shape[-1] == 2:\n        return np.arctan2(vecs[:, 1], vecs[:, 0])\n    raise ValueError("vecs can either be a 2d vector or an array of 2d vectors")\n\n\ndef normalize(vecs: np.ndarray, axis: int = -1) -> np.ndarray:\n    """\n    Returns a normalized version of vecs\n\n    Args:\n        vecs (np.ndarray): The vectors to normalize\n        axis (int, optional): The axis to use for lengths. Defaults to -1.\n\n    Returns:\n        np.ndarray: The normalized vectors\n    """\n    return vecs / np.linalg.norm(vecs, axis=axis, keepdims=True)\n\n\n@my_njit\ndef lerp(\n    values_to_lerp: np.ndarray,\n    start1: np.ndarray,\n    stop1: np.ndarray,\n    start2: np.ndarray,\n    stop2: np.ndarray,\n) -> np.ndarray:\n    """\n    Linearly interpolates (lerps) from one sin_pitchace `[start1, stop1]` to another\n    `[start2, stop2]`. `start1 >= stop1` and `start2 >= stop2` are allowed. If ns is a\n    2d array, then start1, stop1, start2, stop2 must be 1d vectors. This allows for\n    lerping in any n-dim sin_pitchace\n\n    >>> import numpy as np\n    >>> x = np.array([1, 2, 3])\n    >>> lerp(x, 0, 10, 30, 100)\n    >>> array([37., 44., 51.])\n\n    Args:\n        values_to_lerp (np.array): The points to interpolate\n        start1 (np.array): The beginning of the original sin_pitchace\n        stop1 (np.array): The end of the original sin_pitchace\n        start2 (np.array): The beginning of the target sin_pitchace\n        stop2 (np.array): The end of the target sin_pitchace\n\n    Returns:\n        np.array: The interpolated points\n    """\n    return (values_to_lerp - start1) / (stop1 - start1) * (stop2 - start2) + start2\n\n\ndef calculate_radius_from_points(points: np.ndarray) -> np.ndarray:\n    """\n    Given a three points this function calculates the radius of the circle that passes\n    through these points\n\n    Based on: https://math.stackexchange.com/questions/133638/\n    how-does-this-equation-to-find-the-radius-from-3-points-actually-work\n\n    Args:\n        points (np.ndarray): The points for which should be used to calculate the radius\n\n    Returns:\n        np.ndarray: The calculated radius\n    """\n    # implements the equation discussed here:\n    #\n    # assert points.shape[-2:] == (3, 2)\n    # get side lengths\n    points_circular = points[..., [0, 1, 2, 0], :]\n    len_sides = trace_distance_to_next(points_circular)\n\n    # calc prod of sides\n    prod_of_sides = np.prod(len_sides, axis=-1, keepdims=True)\n\n    # calc area of triangle\n    # https://www.mathopenref.com/heronsformula.html\n\n    # calc half of perimeter\n    perimeter = np.sum(len_sides, axis=-1, keepdims=True)\n    half_perimeter = perimeter / 2\n    half_perimeter_minus_sides = half_perimeter - len_sides\n    area_sqr = (\n        np.prod(half_perimeter_minus_sides, axis=-1, keepdims=True) * half_perimeter\n    )\n    area = np.sqrt(area_sqr)\n\n    radius = prod_of_sides / (area * 4)\n\n    radius = radius[..., 0]\n    return radius\n\n\nNumeric = TypeVar("Numeric", float, np.ndarray)\n\n\ndef linearly_combine_values_over_time(\n    tee: float, delta_time: float, previous_value: Numeric, new_value: Numeric\n) -> Numeric:\n    """\n    Linear combination of two values over time\n    (see https://de.wikipedia.org/wiki/PT1-Glied)\n    Args:\n        tee (float): The parameter selecting how much we keep from the previous value\n        and how much we update from the new\n        delta_time (float): The time difference between the previous and new value\n        previous_value (Numeric): The previous value\n        new_value (Numeric): The next value\n\n    Returns:\n        Numeric: The combined value\n    """\n    tee_star = 1 / (tee / delta_time + 1)\n    combined_value: Numeric = tee_star * (new_value - previous_value) + previous_value\n    return combined_value\n\n\ndef odd_square(values: Numeric) -> Numeric:\n    return cast(Numeric, np.sign(values) * np.square(values))\n\n\ndef euler_angles_to_quaternion(euler_angles: np.ndarray) -> np.ndarray:\n    """\n    Converts Euler angles to a quaternion representation.\n\n    Args:\n        euler_angles (np.ndarray): Euler angles as an [...,3] array. Order is\n        [roll, pitch, yaw]\n\n    Returns:\n        np.ndarray: The quaternion representation in [..., 4] [x, y, z, w] order\n    """\n    roll_index, pitch_index, yaw_index = 0, 1, 2\n    sin_values = np.sin(euler_angles * 0.5)\n    cos_values = np.cos(euler_angles * 0.5)\n\n    cos_yaw = cos_values[..., yaw_index]\n    sin_yaw = sin_values[..., yaw_index]\n    cos_pitch = cos_values[..., pitch_index]\n    sin_pitch = sin_values[..., pitch_index]\n    cos_roll = cos_values[..., roll_index]\n    sin_roll = sin_values[..., roll_index]\n\n    quaternion_x = sin_roll * cos_pitch * cos_yaw - cos_roll * sin_pitch * sin_yaw\n    quaternion_y = cos_roll * sin_pitch * cos_yaw + sin_roll * cos_pitch * sin_yaw\n    quaternion_z = cos_roll * cos_pitch * sin_yaw - sin_roll * sin_pitch * cos_yaw\n    quaternion_w = cos_roll * cos_pitch * cos_yaw + sin_roll * sin_pitch * sin_yaw\n\n    return_value = np.stack(\n        [quaternion_x, quaternion_y, quaternion_z, quaternion_w], axis=-1\n    )\n    return return_value\n\n\ndef quaternion_to_euler_angles(quaternion: np.ndarray) -> np.ndarray:\n    """\n    Converts a quaternion to Euler angles. Based on\n    https://stackoverflow.com/a/37560411.\n\n    Args:\n        quaternion (np.ndarray): The quaternion as an [..., 4] array. Order is\n        [x, y, z, w]\n\n    Returns:\n        np.ndarray: The Euler angles as an [..., 3] array. Order is [roll, pitch, yaw]\n    """\n    x_index, y_index, z_index, w_index = 0, 1, 2, 3\n    x_value = quaternion[..., x_index]\n    y_value = quaternion[..., y_index]\n    z_value = quaternion[..., z_index]\n    w_value = quaternion[..., w_index]\n\n    y_square = y_value * y_value\n    temporary_0 = -2.0 * (y_square + z_value * z_value) + 1.0\n    temporary_1 = +2.0 * (x_value * y_value + w_value * z_value)\n    temporary_2 = -2.0 * (x_value * z_value - w_value * y_value)\n    temporary_3 = +2.0 * (y_value * z_value + w_value * x_value)\n    temporary_4 = -2.0 * (x_value * x_value + y_square) + 1.0\n\n    temporary_2 = np.clip(temporary_2, -1.0, 1.0)\n\n    roll = np.arctan2(temporary_3, temporary_4)\n    pitch = np.arcsin(temporary_2)\n    yaw = np.arctan2(temporary_1, temporary_0)\n\n    return_value = np.stack([roll, pitch, yaw], axis=-1)\n    return return_value\n\n\ndef points_inside_ellipse(\n    points: np.ndarray,\n    center: np.ndarray,\n    major_direction: np.ndarray,\n    major_radius: float,\n    minor_radius: float,\n) -> np.ndarray:\n    """\n    Checks if a set of points are inside an ellipse.\n\n    Args:\n        points: The points as an [..., 2] array.\n        center: The center of the ellipse as an [2] array.\n        major_direction: The major direction of the ellipse as an [2] array.\n        major_radius: The major radius of the ellipse.\n        minor_radius: The minor radius of the ellipse.\n\n    Returns:\n        An [...] array of booleans.\n    """\n\n    # Center the points around the center\n    # [..., 2]\n    centered_points = points - center\n    # Calculate angle of the major direction with the x-axis\n    # [1]\n    major_direction_angle = float(angle_from_2d_vector(major_direction))\n    # Rotate the points around the center of the ellipse\n    # [..., 2]\n    rotated_points = rotate(centered_points, -major_direction_angle)\n    # [2]\n    radii_square = np.array([major_radius, minor_radius]) ** 2\n    # [...]    [..., 2]              [2]\n    criterion_value = (rotated_points**2 / radii_square).sum(axis=-1)\n\n    mask_is_inside = criterion_value < 1\n    return mask_is_inside\n\n\ndef center_of_circle_from_3_points(\n    point_1: np.ndarray,\n    point_2: np.ndarray,\n    point_3: np.ndarray,\n    atol: float = 1e-6,\n) -> np.ndarray:\n    """\n    Calculates the center of a circle from three points.\n\n    Adapted from http://paulbourke.net/geometry/circlesphere/Circle.cpp (CalcCircle)\n\n    Args:\n        point_1: The first point as an [2] array.\n        point_2: The second point as an [2] array.\n        point_3: The third point as an [2] array.\n\n    Returns:\n        The center of the circle as an [2] array.\n    """\n    y_delta_1 = point_2[1] - point_1[1]\n    x_delta_1 = point_2[0] - point_1[0]\n    y_delta_2 = point_3[1] - point_2[1]\n    x_delta_2 = point_3[0] - point_2[0]\n\n    if np.isclose(x_delta_1, 0.0, atol=atol) and np.isclose(x_delta_2, 0.0, atol=atol):\n        center_x = (point_2[0] + point_3[0]) / 2\n        center_y = (point_1[1] + point_2[1]) / 2\n        return np.array([center_x, center_y])  # early return\n\n    slope_1 = y_delta_1 / x_delta_1\n    slope_2 = y_delta_2 / x_delta_2\n    if np.isclose(slope_1, slope_2, atol=atol):\n        raise ValueError("Points are colinear")\n\n    center_x = (\n        slope_1 * slope_2 * (point_1[1] - point_3[1])\n        + slope_2 * (point_1[0] + point_2[0])\n        - slope_1 * (point_2[0] + point_3[0])\n    ) / (2 * (slope_2 - slope_1))\n\n    center_y = (\n        -(center_x - (point_1[0] + point_2[0]) / 2) / slope_1\n        + (point_1[1] + point_2[1]) / 2\n    )\n\n    center = np.array([center_x, center_y])\n    return center\n\n\n@my_njit\ndef circle_fit(coords: np.ndarray, max_iter: int = 99) -> np.ndarray:\n    """\n    Fit a circle to a set of points. This function is adapted from the hyper_fit function\n    in the circle-fit package (https://pypi.org/project/circle-fit/). The function is\n    a njit version of the original function with some input validation removed. Furthermore,\n    the residuals are not calculated or returned.\n\n    Args:\n        coords: The coordinates of the points as an [N, 2] array.\n        max_iter: The maximum number of iterations.\n\n    Returns:\n        An array with 3 elements:\n        - center x\n        - center y\n        - radius\n    """\n\n    X = coords[:, 0]\n    Y = coords[:, 1]\n\n    n = X.shape[0]\n\n    Xi = X - X.mean()\n    Yi = Y - Y.mean()\n    Zi = Xi * Xi + Yi * Yi\n\n    # compute moments\n    Mxy = (Xi * Yi).sum() / n\n    Mxx = (Xi * Xi).sum() / n\n    Myy = (Yi * Yi).sum() / n\n    Mxz = (Xi * Zi).sum() / n\n    Myz = (Yi * Zi).sum() / n\n    Mzz = (Zi * Zi).sum() / n\n\n    # computing the coefficients of characteristic polynomial\n    Mz = Mxx + Myy\n    Cov_xy = Mxx * Myy - Mxy * Mxy\n    Var_z = Mzz - Mz * Mz\n\n    A2 = 4 * Cov_xy - 3 * Mz * Mz - Mzz\n    A1 = Var_z * Mz + 4.0 * Cov_xy * Mz - Mxz * Mxz - Myz * Myz\n    A0 = Mxz * (Mxz * Myy - Myz * Mxy) + Myz * (Myz * Mxx - Mxz * Mxy) - Var_z * Cov_xy\n    A22 = A2 + A2\n\n    # finding the root of the characteristic polynomial\n    y = A0\n    x = 0.0\n    for _ in range(max_iter):\n        Dy = A1 + x * (A22 + 16.0 * x * x)\n        x_new = x - y / Dy\n        if x_new == x or not np.isfinite(x_new):\n            break\n        y_new = A0 + x_new * (A1 + x_new * (A2 + 4.0 * x_new * x_new))\n        if abs(y_new) >= abs(y):\n            break\n        x, y = x_new, y_new\n\n    det = x * x - x * Mz + Cov_xy\n    X_center = (Mxz * (Myy - x) - Myz * Mxy) / det / 2.0\n    Y_center = (Myz * (Mxx - x) - Mxz * Mxy) / det / 2.0\n\n    x = X_center + X.mean()\n    y = Y_center + Y.mean()\n    r = np.sqrt(abs(X_center**2 + Y_center**2 + Mz))\n\n    return np.array([x, y, r])\n\n\nif __name__ == "__main__":\n    p1, p2, p3 = unit_2d_vector_from_angle(np.array([0, 0.3, 0.31]))\n    print(center_of_circle_from_3_points(p1, p2, p3))\n\n    p1, p2, p3 = unit_2d_vector_from_angle(np.array([0, 0.8, 4])) + 10\n    print(center_of_circle_from_3_points(p1, p2, p3))\n\n    p1, p2, p3 = np.array([-1, 0.0]), np.array([0, 1.0]), np.array([1.0, 0.0])\n    print(center_of_circle_from_3_points(p1, p2, p3))\n\n    p1, p2, p3 = np.array([0, 0.0]), np.array([0, 1.0]), np.array([0.0, 2.0])\n    print(center_of_circle_from_3_points(p1, p2, p3))\n')
    __stickytape_write_module('common.py', b'from typing import Any\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport plotly.graph_objects as go\nimport streamlit as st\nfrom chabo_common.constants.cone_types import ConeTypes\nfrom chabo_common.utils.math_utils import rotate, unit_2d_vector_from_angle\nfrom matplotlib.axes._axes import Axes\nfrom matplotlib.figure import Figure\nfrom traitlets import Float\n\nfrom chabo_pathing.types import FloatArray\n\n\ndef calculate_pose_triangle_position(\n    position: FloatArray, direction: FloatArray, size: float\n) -> FloatArray:\n    pos_1 = position + direction * size\n    pos_2 = position - rotate(direction, np.pi / 2) * size * 0.5\n    pos_3 = position - rotate(direction, -np.pi / 2) * size * 0.5\n    return np.array([pos_1, pos_2, pos_3])\n\n\nCONE_TYPE_TO_COLOR = {\n    ConeTypes.UNKNOWN: "gray",\n    ConeTypes.BLUE: "#00BFFF",\n    ConeTypes.YELLOW: "gold",\n    ConeTypes.ORANGE_BIG: "orange",\n    ConeTypes.ORANGE_SMALL: "orange",\n}\n\n\ndef visualize_configuration(\n    position: FloatArray,\n    direction: FloatArray,\n    cones_by_type: list[FloatArray],\n    *,\n    with_cone_index: bool,\n    with_lines: bool,\n    do_show: bool,\n) -> tuple[Figure, Axes]:\n    position_triangle = calculate_pose_triangle_position(position, direction, 1)\n    fig, ax = plt.subplots()\n    ax.fill(*position_triangle.T, color="red", label="Vehicle Pose")\n\n    marker_string = "-o" if with_lines else "o"\n    text_offset = 0.5\n    for cone_type, cones in zip(ConeTypes, cones_by_type):\n        if len(cones) == 0:\n            continue\n        color = CONE_TYPE_TO_COLOR[cone_type]\n        ax.plot(\n            *cones.T,\n            marker_string,\n            color=color,\n            label="LEFT" if cone_type == ConeTypes.LEFT else "RIGHT",\n        )\n        if with_cone_index:\n            for i, (x, y) in enumerate(cones, start=1):\n                ax.text(x - text_offset, y - text_offset, str(i))\n    ax.set_xticks([])\n    ax.set_yticks([])\n    ax.axis("equal")\n    ax.legend(loc="upper left")\n\n    if do_show:\n        st.pyplot(fig)  # type: ignore\n\n    return fig, ax\n\n\ndef get_cones_for_configuration(\n    configuration: str,\n) -> tuple[FloatArray, FloatArray, list[FloatArray]]:\n    rng = np.random.default_rng(0)\n    vehicle_position = np.array([0, 0], dtype=float)\n    vehicle_direction = np.array([1, 0], dtype=float)\n    if configuration == "Straight":\n\n        cones_x = np.arange(-2, 20, 4)\n        noise_range = 0.3\n        cones_left_y = np.ones(len(cones_x)) * 1.5 + rng.uniform(\n            -noise_range, noise_range, len(cones_x)\n        )\n\n        cones_right_y = np.ones(len(cones_x)) * -1.5 + rng.uniform(\n            -noise_range, noise_range, len(cones_x)\n        )\n\n        cones_left = np.column_stack((cones_x, cones_left_y))\n        cones_right = np.column_stack((cones_x, cones_right_y))\n\n    elif configuration == "Simple Corner":\n        phi_inner = np.arange(0, np.pi / 2, np.pi / 15)\n        phi_outer = np.arange(0, np.pi / 2, np.pi / 20)\n\n        points_inner = unit_2d_vector_from_angle(phi_inner) * 9\n        points_outer = unit_2d_vector_from_angle(phi_outer) * 12\n\n        center = np.mean((points_inner[:2] + points_outer[:2]) / 2, axis=0)\n        points_inner -= center\n        points_outer -= center\n\n        rotated_points_inner = rotate(points_inner, -np.pi / 2)\n        rotated_points_outer = rotate(points_outer, -np.pi / 2)\n        cones_left = rotated_points_inner\n        cones_right = rotated_points_outer\n\n    elif configuration == "Hairpin":\n        cones_left = np.array(\n            [\n                [-1.93870544, 8.5625],\n                [-1.75120544, 2.9375],\n                [-2.12620544, 12.5625],\n                [-1.93870544, 17.0625],\n                [-1.18870544, 20.0625],\n                [0.87379456, 22.3125],\n                [2.56129456, 23.0625],\n                [3.68629456, 23.8125],\n                [7.24879456, 25.5],\n                [10.43629456, 26.8125],\n                [13.81129456, 28.3125],\n                [17.93629456, 28.875],\n                [21.12379456, 29.25],\n                [23.81129456, 29.25],\n                [26.43629456, 29.25],\n                [29.62379456, 29.625],\n                [32.43629456, 30.0],\n                [35.24879456, 30.9375],\n                [37.49879456, 32.25],\n                [39.74879456, 33.75],\n                [40.87379456, 20.25],\n                [41.81129456, 34.875],\n                [43.87379456, 21.0],\n                [44.43629456, 34.875],\n                [46.49879456, 22.6875],\n                [46.68629456, 33.9375],\n                [48.18629456, 32.625],\n                [48.56129456, 24.9375],\n                [48.93629456, 30.75],\n                [49.31129456, 28.125],\n                [38.62379456, 10.3125],\n                [37.31129456, 12.1875],\n                [39.65629743, 8.18879957],\n                [34.75933012, 13.1045134],\n                [32.62379456, 13.5],\n                [30.18629456, 12.75],\n                [37.12379456, 19.875],\n                [40.48549743, 4.98658],\n                [34.19018003, 19.2519854],\n                [31.31129456, 19.125],\n                [28.12379456, 18.5625],\n                [24.93629456, 18.375],\n                [27.74879456, 11.4375],\n                [21.68629456, 17.8125],\n                [19.06129456, 16.875],\n                [16.06129456, 15.75],\n                [13.43629456, 13.875],\n                [11.93629456, 12.0],\n                [10.43629456, 9.5],\n            ]\n        )[11:30]\n        cones_right = np.array(\n            [\n                [1.24879456, 8.75],\n                [2.18629456, 18.1875],\n                [1.24879456, 12.375],\n                [3.12379456, 19.6875],\n                [1.43629456, 16.3125],\n                [5.56129456, 20.8125],\n                [14.74879456, 24.9375],\n                [18.68629456, 25.6875],\n                [21.31129456, 25.6875],\n                [11.74879456, 23.625],\n                [23.81129456, 25.875],\n                [26.62379456, 26.0625],\n                [27.89708838, 22.13631838],\n                [30.18629456, 26.25],\n                [31.12379456, 22.3125],\n                [33.37379456, 27.0],\n                [33.56129456, 22.6875],\n                [36.74879456, 23.0625],\n                [36.93629456, 28.3125],\n                [39.56129456, 29.4375],\n                [39.93629456, 23.4375],\n                [41.06129456, 31.125],\n                [42.37379456, 24.1875],\n                [42.74879456, 31.875],\n                [44.43629456, 24.9375],\n                [44.62379456, 31.3125],\n                [45.18629456, 26.25],\n                [45.56129456, 29.8125],\n                [45.74879456, 28.125],\n                [35.62379456, 8.9375],\n                [33.74879456, 10.0625],\n                [35.81129456, 7.0625],\n                [29.81129456, 9.125],\n                [24.74879456, 21.5625],\n                [21.12379456, 21.1875],\n                [17.93629456, 20.25],\n                [14.74879456, 18.9375],\n                [11.37379456, 16.875],\n                [8.37379456, 22.5],\n                [9.12379456, 14.4375],\n                [7.62379456, 11.25],\n                [6.31129456, 7.8125],\n                [6.31129456, 4.625],\n            ]\n        )\n        mask_keep_right = np.zeros(len(cones_right), dtype=bool)\n        mask_keep_right[10:29] = True\n\n        cones_right = cones_right[mask_keep_right]\n\n        vehicle_position = (cones_left[0] + cones_right[0]) / 2\n\n    # shuffle\n    cones_left = cones_left[rng.random(len(cones_left)).argsort()]\n    cones_right = cones_right[rng.random(len(cones_right)).argsort()]\n\n    cones = [np.zeros((0, 2)), cones_left, cones_right]\n    cones[ConeTypes.LEFT] = cones_left\n    cones[ConeTypes.RIGHT] = cones_right\n    return vehicle_position, vehicle_direction, cones\n\n\ndef create_animation(frames: list[go.Frame]) -> go.Figure:\n    return go.Figure(\n        data=frames[0]["data"],\n        layout=go.Layout(\n            updatemenus=[\n                dict(\n                    type="buttons",\n                    buttons=[\n                        dict(\n                            label="Play",\n                            method="animate",\n                            args=[\n                                None,\n                                {\n                                    "frame": {\n                                        "duration": 1000,\n                                    },\n                                    "transition": {\n                                        "duration": 0,\n                                    },\n                                },\n                            ],\n                        )\n                    ],\n                )\n            ],\n        ),\n        frames=frames,\n    )\n')
    __stickytape_write_module('chabo_pathing/__init__.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: Entry point of pathing. This file checks python and dependency versions\nand exits if the versions are not correct. Effectively it checks if the .venv is\nactivated.\nProject: FaSTTUBe Chabo Pathing\n"""\nimport sys\n\nallowed_versions = {(3, 9), (3, 10)}\nactual_version = sys.version_info[:2]\nif actual_version not in allowed_versions:\n    REQUIRED_STRING = ", ".join(f"{v[0]}.{v[1]}" for v in allowed_versions)\n    ACTUAL_STRING = ".".join(map(str, actual_version))\n    raise SystemExit(\n        f"Python Version is not one of {REQUIRED_STRING} (it actually is {ACTUAL_STRING})."\n        " Do not forget to activate the virtual environment when running without"\n        " roslaunch (either with rosrun or invoking directly)."\n    )\n')
    __stickytape_write_module('chabo_pathing/types.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: Define types that are used commonly in the whole package\nProject: FaSTTUBe Chabo Pathing\n"""\n\nfrom typing import TYPE_CHECKING, Any, Literal\n\nimport numpy as np\nfrom chabo_common.constants.cone_types import ConeTypes\nfrom numpy.typing import NDArray\n\nif TYPE_CHECKING:\n    GenericArray = NDArray[Any]\n    FloatArray = NDArray[np.float_]\n    IntArray = NDArray[np.int_]\n    BoolArray = NDArray[np.bool_]\n    SortableConeTypes = Literal[\n        ConeTypes.LEFT,\n        ConeTypes.BLUE,\n        ConeTypes.RIGHT,\n        ConeTypes.YELLOW,\n    ]\nelse:\n    GenericArray = None  # pylint: disable=invalid-name\n    FloatArray = None  # pylint: disable=invalid-name\n    IntArray = None  # pylint: disable=invalid-name\n    BoolArray = None  # pylint: disable=invalid-name\n    SortableConeTypes = ConeTypes\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/adjacency_matrix.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This File calculates the Adjacency Matrix\nProject: FaSTTUBe Chabo Pathing\n"""\n\nfrom typing import Tuple, cast\n\nimport numpy as np\nfrom chabo_common.utils.math_utils import calc_pairwise_distances\n\nfrom chabo_pathing.sorting_cones.trace_sorter.common import breadth_first_order\nfrom chabo_pathing.types import FloatArray, IntArray\n\n\ndef find_k_closest_in_point_cloud(pairwise_distances: FloatArray, k: int) -> IntArray:\n    """\n    Finds the indices of the k closest points for each point in a point cloud from its\n    pairwise distances.\n\n    Args:\n        pairwise_distances: A square matrix containing the distance from each\n        point to every other point\n        k: The number closest points (indices) to return of each point\n    Returns:\n        np.array: An (n,k) array containing the indices of the `k` closest points.\n    """\n    return cast(IntArray, np.argsort(pairwise_distances, axis=1)[:, :k])\n\n\ndef create_adjacency_matrix(\n    trace: FloatArray,\n    n_neighbors: int,\n    start_idx: int,\n    max_dist: float,\n) -> Tuple[IntArray, IntArray]:\n    """\n    Creates the adjacency matrix that defines the possible points each point can be connected with\n    Args:\n        trace: The trace containing all the points\n        n_neighbors: The maximum number of neighbors each node can have\n        start_idx: The index from which the trace starts\n        max_dist: The maximum distance two points can have in order for them to\n        be considered possible neighbors\n    Returns:\n        Tuple[np.array, np.array]: Three values are returned. First a square boolean\n        matrix indicating at each position if two nodes are connected. The second 1d\n        matrix contains the reachable nodes from `start_idx`.\n    """\n    n_points = trace.shape[0]\n\n    pairwise_distances: FloatArray = calc_pairwise_distances(trace, dist_to_self=np.inf)\n\n    k_closest_each = find_k_closest_in_point_cloud(pairwise_distances, n_neighbors)\n\n    sources = np.repeat(np.arange(n_points), n_neighbors)\n    targets = k_closest_each.flatten()\n\n    adjacency_matrix: IntArray = np.zeros((n_points, n_points), dtype=np.uint8)\n\n    adjacency_matrix[\n        sources, targets\n    ] = 1  # for each node set its closest n_neighbor to 1\n    adjacency_matrix[\n        pairwise_distances > (max_dist * max_dist)\n    ] = 0  # but if distance is too high set to 0 again\n\n    # remove all edges that don\'t have a revere i.e. convert to undirected graph\n    adjacency_matrix = np.logical_and(adjacency_matrix, adjacency_matrix.T)\n\n    # adjacency_matrix = filter_adjacency_matrix_remove_lateral_connections(\n    #     adjacency_matrix_raw, trace, np.deg2rad(1)\n    # )\n    reachable_nodes = breadth_first_order(adjacency_matrix, start_idx)\n\n    # completely disconnect nodes that are not reachable from start node\n    # assume that all nodes will be disconnected\n    nodes_to_disconnect = np.ones(n_points, dtype=bool)\n    # but for the reachable nodes don\'t do anything\n    nodes_to_disconnect[reachable_nodes] = False\n\n    # disconnect the remaining nodes in both directions\n    adjacency_matrix[:, nodes_to_disconnect] = 0\n    adjacency_matrix[nodes_to_disconnect, :] = 0\n\n    return adjacency_matrix, reachable_nodes\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/common.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This File provides several functions used in several other files in the\nsorting algorithm\nProject: FaSTTUBe Chabo Pathing\n"""\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport numpy as np\nfrom chabo_common.utils.math_utils import my_njit\n\nfrom chabo_pathing.types import FloatArray, IntArray\n\nif not TYPE_CHECKING:\n\n    @my_njit\n    def cast(  # pylint: disable=function-redefined\n        type_: Any, value_: Any  # pylint: disable=unused-argument\n    ) -> Any:\n        "Dummy numba jit function"\n        return value_\n\n\nclass NoPathError(RuntimeError):\n    """\n    A special exception thrown when no path can be found (i.e. no configuration)\n    """\n\n\ndef get_configurations_diff(points: FloatArray, configurations: IntArray) -> FloatArray:\n    """\n    Gets the difference from each point to its next for each order defined by configurations\n    Args:\n        points: The points for which the differences should be calculated\n        configurations: (n,m), all the configurations that define the orders\n    Returns:\n        np.array: The difference from one point to the next for each configuration\n    """\n    result: FloatArray\n    result = points[configurations[..., :-1]]\n    result -= points[configurations[..., 1:]]\n    return result\n\n\n@my_njit\ndef breadth_first_order(adjacency_matrix: IntArray, start_idx: int) -> IntArray:\n    """\n    Returns the nodes reachable from `start_idx` in BFS order\n    Args:\n        adjacency_matrix: The adjacency matrix describing the graph\n        start_idx: The index of the starting node\n    Returns:\n        np.array: An array containing the nodes reachable from the starting node in BFS order\n    """\n    visited = np.zeros(adjacency_matrix.shape[0], dtype=np.uint8)\n    queue = np.full(adjacency_matrix.shape[0], fill_value=-1)\n\n    queue[0] = start_idx\n    visited[start_idx] = 1\n\n    queue_pointer = 0\n    queue_end_pointer = 0\n\n    while queue_pointer <= queue_end_pointer:\n        node = queue[queue_pointer]\n\n        next_nodes = np.argwhere(adjacency_matrix[node])[:, 0]\n        for i in next_nodes:\n            if not visited[i]:\n                queue_end_pointer += 1\n                queue[queue_end_pointer] = i\n                visited[i] = 1\n        queue_pointer += 1\n    return cast(IntArray, queue[:queue_pointer])\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/core_trace_sorter.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This module provides functionality for sorting a trace of cones into a\nplausible track\nProject: FaSTTUBe Chabo Pathing\n"""\nfrom typing import Optional, Tuple, cast\n\nimport numpy as np\nfrom chabo_common.utils.math_utils import points_inside_ellipse, vec_angle_between\n\nfrom chabo_pathing.sorting_cones.trace_sorter.common import NoPathError\nfrom chabo_pathing.sorting_cones.trace_sorter.sort_trace import sort_trace\nfrom chabo_pathing.types import FloatArray, IntArray, SortableConeTypes\n\n\nclass TraceSorter:\n    """\n    Wraps the trace sorting functionality into a class\n    """\n\n    def __init__(\n        self,\n        max_n_neighbors: int,\n        max_dist: float,\n        max_dist_to_first: float,\n        max_length: int,\n        threshold_directional_angle: float,\n        threshold_absolute_angle: float,\n    ):\n        """\n        Constructor for TraceSorter class\n        Args:\n            max_n_neighbors: The maximum allowed number of neighbors for each node\n            during sorting\n            max_dist: The maximum allowed distance for two nodes to be\n            considered neighbors\n            max_dist_to_first: The maximum allowed distance in order for a node\n            to be considered a viable first node\n        """\n        self.max_n_neighbors = max_n_neighbors\n        self.max_dist = max_dist\n        self.max_dist_to_first = max_dist_to_first\n        self.max_length = max_length\n        self.threshold_directional_angle = threshold_directional_angle\n        self.threshold_absolute_angle = threshold_absolute_angle\n\n    def sort(  # pylint: disable=too-many-arguments\n        self,\n        trace: FloatArray,\n        cone_type: SortableConeTypes,\n        car_pos: FloatArray,\n        car_dir: FloatArray,\n        start_idx: Optional[int] = None,\n        first_k_indices_must_be: Optional[IntArray] = None,\n    ) -> Tuple[FloatArray, IntArray]:\n        """\n        Sorts a provided trace. Applies basic tests to remove outlier configurations (such as\n        when the nearest cone is too far)\n        Args:\n            trace: The trace to be sorted\n            cone_type: The type of cone to be sorted\n            car_pos: The position from which the sorting happens\n            car_dir: The direction towards which the car goes at the start\n            start_idx: The index of the starting point. If not set then\n            the point closest to `car_pos` is used . Defaults to None.\n        Returns:\n            np.ndarray: The sorted trace, `len(return_value) <= len(trace)`\n        """\n        # updates the given trace to exclude passed cones\n        # trace = self.remove_cones_behind(trace)\n        trace_sorted_idxs: IntArray\n        empty_idxs_array: IntArray = np.zeros(0, dtype=np.int_)\n        # nothing to sort\n        if len(trace) == 0:\n            trace_sorted_idxs = empty_idxs_array\n        else:\n            distances_to_car = np.linalg.norm(trace - car_pos, axis=-1)\n            dist_to_closest_cone = distances_to_car.min()\n\n            if len(trace) == 1:\n                trace_sorted_idxs = np.zeros(1, dtype=np.int_)\n\n            elif len(trace) == 2:\n                # for cases where only 2 cones are available\n                # just return the cones sorted by distance since there is no better algorithm\n                trace_sorted_idxs = distances_to_car.argsort()\n\n                # if the distance between the two points is too large then only get the\n                # first point\n                if np.abs(np.diff(distances_to_car)) > self.max_dist:\n                    trace_sorted_idxs = trace_sorted_idxs[:1]\n\n            else:\n                if start_idx is None:\n                    angles_to_car = vec_angle_between(trace - car_pos, car_dir)\n                    start_idx = self.select_starting_cone(\n                        car_pos, car_dir, trace, angles_to_car, distances_to_car\n                    )\n\n                if start_idx is None:\n                    trace_sorted_idxs = empty_idxs_array\n                else:\n                    n_neighbors = min(self.max_n_neighbors, len(trace) - 1)\n                    try:\n                        trace_sorted_idxs = sort_trace(\n                            trace,\n                            cone_type,\n                            n_neighbors,\n                            start_idx,\n                            self.threshold_directional_angle,\n                            self.threshold_absolute_angle,\n                            car_dir,\n                            self.max_dist,\n                            self.max_length,\n                            first_k_indices_must_be,\n                        )\n\n                    # if no configurations can be found, then just return the first trace\n                    except NoPathError:\n                        trace_sorted_idxs = np.array([start_idx], dtype=np.int_)\n\n        sorted_trace = trace[trace_sorted_idxs]\n\n        return sorted_trace, trace_sorted_idxs\n\n    def select_starting_cone(\n        self,\n        car_position: FloatArray,\n        car_direction: FloatArray,\n        cones: FloatArray,\n        trace_angles: FloatArray,\n        trace_distances: FloatArray,\n    ) -> Optional[int]:\n        """\n        Return the index of the starting cone\n        Args:\n            trace_angles: The trace from which to choose\n            trace_distances: The distance to the starting\n        Returns:\n            int: The index of the stating cone\n        """\n        mask_is_in_ellipse = points_inside_ellipse(\n            cones,\n            car_position,\n            car_direction,\n            self.max_dist_to_first * 1.3,\n            self.max_dist_to_first / 1.3,\n        )\n\n        mask_is_valid_angle = np.abs(trace_angles) < np.pi / 1.1\n        mask_is_closest = trace_distances == trace_distances.min()\n        mask_is_valid = mask_is_valid_angle * mask_is_in_ellipse * mask_is_closest\n\n        if np.any(mask_is_valid):\n            # return the position of the first true\n            start_idx = int(np.argmax(mask_is_valid))\n        else:\n            start_idx = None\n\n        return start_idx\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/sort_trace.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This File provides the core algorithm for sorting a trace of cones into a\nplausible track\nProject: FaSTTUBe Chabo Pathing\n"""\nimport sys\nfrom typing import Optional\n\nimport numpy as np\n\nfrom chabo_pathing.sorting_cones.trace_sorter.adjacency_matrix import (\n    create_adjacency_matrix,\n)\nfrom chabo_pathing.sorting_cones.trace_sorter.cost_function import cost_configurations\nfrom chabo_pathing.sorting_cones.trace_sorter.end_configurations import (\n    find_all_end_configurations,\n)\nfrom chabo_pathing.types import FloatArray, IntArray, SortableConeTypes\n\n\ndef sort_trace(\n    trace: FloatArray,\n    cone_type: SortableConeTypes,\n    n_neighbors: int,\n    start_idx: int,\n    threshold_directional_angle: float,\n    threshold_absolute_angle: float,\n    vehicle_direction: FloatArray,\n    max_dist: float = np.inf,\n    max_length: int = sys.maxsize,\n    first_k_indices_must_be: Optional[IntArray] = None,\n) -> IntArray:\n    """\n    Sorts a set of points such that the sum of the angles between the points is minimal.\n    If a point is too far away, from any neighboring points, it is considered an outlier\n    and is removed from the ordering\n    Args:\n        trace: The points to be ordered\n        cone_type: The type of cone to be sorted (left/right)\n        n_neighbors: The number of neighbors to be considered. For exhaustive\n        search set to `len(trace) - 1`\n        start_idx: The index of the point to be set first in the ordering.\n        max_dist: The maximum valid distance between neighbors\n        Defaults to np.inf\n        max_length: The maximum valid length of the tree\n        Defaults to np.inf\n        cone_type:: The type of cone that is being sorted (left or right\n        trace)\n    Raises:\n        ValueError: If `n_neighbors` is greater than len(trace) - 1\n        RuntimeError: If no valid path can be computed\n    Returns:\n        np.array[int]: A list of indexes of the points in the optimal ordering\n    """\n\n    if n_neighbors >= len(trace):\n        raise ValueError(\n            f"sort_trace was called with n_neighbors ({n_neighbors}) >= len(trace) ({len(trace)})."\n        )\n\n    adjacency_matrix, reachable_nodes = create_adjacency_matrix(\n        trace=trace, n_neighbors=n_neighbors, start_idx=start_idx, max_dist=max_dist\n    )\n\n    target_length = min(reachable_nodes.shape[0], max_length)\n\n    if first_k_indices_must_be is None:\n        first_k_indices_must_be = np.arange(0)\n\n    all_end_configurations, _ = find_all_end_configurations(\n        trace,\n        cone_type,\n        start_idx,\n        adjacency_matrix,\n        target_length,\n        threshold_directional_angle,\n        threshold_absolute_angle,\n        first_k_indices_must_be,\n        store_all_end_configurations=False,  # this is only used for testing/debugging/visualization purposes and should be set to False in production\n    )\n\n    best_configuration: IntArray\n    if len(all_end_configurations) == 1:\n        best_configuration = all_end_configurations[0]\n    else:\n        costs = cost_configurations(\n            points=trace,\n            configurations=all_end_configurations,\n            cone_type=cone_type,\n            vehicle_direction=vehicle_direction,\n            return_individual_costs=False,\n        )\n        best_configuration = all_end_configurations[np.argmin(costs)]\n\n    best_configuration = best_configuration[best_configuration != -1]\n    return best_configuration\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/cost_function.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This File calculates the costs for the different path versions\nProject: FaSTTUBe Chabo Pathing\n"""\n\nimport numpy as np\nfrom chabo_common.utils.math_utils import vec_angle_between\nfrom traitlets import Float\nfrom typing_extensions import reveal_type\n\nfrom chabo_pathing.sorting_cones.trace_sorter.common import get_configurations_diff\nfrom chabo_pathing.sorting_cones.trace_sorter.cone_distance_cost import (\n    calc_distance_cost,\n)\nfrom chabo_pathing.sorting_cones.trace_sorter.line_segment_intersection import (\n    number_of_intersections_in_configurations,\n)\nfrom chabo_pathing.types import BoolArray, FloatArray, IntArray, SortableConeTypes\n\n\ndef calc_angle_to_next(points: FloatArray, configurations: IntArray) -> FloatArray:\n    """\n    Calculate the angle from one cone to the previous and the next one for all\n    the provided configurations\n    """\n    all_to_next = get_configurations_diff(points, configurations)\n\n    mask_should_overwrite = (configurations == -1)[:, 1:]\n    all_to_next[mask_should_overwrite] = 100\n\n    from_middle_to_next = all_to_next[..., 1:, :]\n    from_prev_to_middle = all_to_next[..., :-1, :]\n    from_middle_to_prev = -from_prev_to_middle\n\n    angles = vec_angle_between(from_middle_to_next, from_middle_to_prev)\n    return angles\n\n\ndef calc_angle_cost_for_configuration(\n    points: FloatArray,\n    configurations: IntArray,\n    cone_type: SortableConeTypes,  # pylint: disable=unused-argument\n) -> FloatArray:\n    """\n    Calculate the angle cost of cone configurations given a set of points and many index\n    lists defining the configurations\n    Args:\n        points: The points to be used\n        configurations: An array of indices defining the configurations\n        cone_type: The type of cones. It is currently unused\n    Returns:\n        np.array: The score of each configuration\n    """\n    angles = calc_angle_to_next(points, configurations)\n\n    is_part_of_configuration = (configurations != -1)[:, 2:]\n\n    # invert angles and normalize between [0-1]\n    angles_as_cost = (np.pi - angles) / np.pi\n\n    angles_as_cost_filtered = angles_as_cost * is_part_of_configuration\n\n    angles_are_under_threshold = np.logical_and(\n        angles < np.deg2rad(40), is_part_of_configuration\n    )\n\n    # we will multiply the score by the number of angles that are under the threshold\n    cost_factors = angles_are_under_threshold.sum(axis=-1) + 1\n\n    # get sum of costs\n    costs: FloatArray = angles_as_cost_filtered.sum(\n        axis=-1\n    ) / is_part_of_configuration.sum(axis=-1)\n\n    costs = costs * cost_factors\n    return costs\n\n\ndef calc_line_segment_intersection_cost(\n    points: FloatArray, configurations: IntArray\n) -> FloatArray:\n    """\n    Calculates the number of intersections in each configuration\n    Args:\n        points: The underlying points\n        configurations: An array of indices defining a configuration of the\n        provided points\n    Returns:\n        np.array: The number of intersections for each configuration\n    """\n\n    exponent: IntArray = number_of_intersections_in_configurations(\n        points, configurations\n    )\n    return_value: FloatArray = np.power(2.0, exponent) - 1.0\n    return return_value\n\n\ndef calc_number_of_cones_cost(configurations: IntArray) -> FloatArray:\n    """\n    Calculates the number of cones in each configuration\n    Args:\n        configurations: An array of indices defining a configuration of the\n        provided points\n    Returns:\n        A cost for each configuration\n    """\n    mask: BoolArray = configurations != -1\n    number_of_cones: IntArray = mask.sum(axis=-1)\n\n    # we prefer longer configurations\n    cost = 1 / number_of_cones\n    return cost\n\n\ndef calc_initial_direction_cost(\n    points: FloatArray, configurations: IntArray, vehicle_direction: FloatArray\n) -> FloatArray:\n    points_configs_first_two = np.diff(points[configurations][:, :2], axis=1)[:, 0]\n    return vec_angle_between(points_configs_first_two, vehicle_direction)\n\n\ndef cost_configurations(\n    points: FloatArray,\n    configurations: IntArray,\n    cone_type: SortableConeTypes,\n    vehicle_direction: FloatArray,\n    *,\n    return_individual_costs: bool,\n) -> FloatArray:\n    """\n    Calculates a cost for each provided configuration\n    Args:\n        points: The underlying points\n        configurations: An array of indices defining a configuration of the\n        provided points\n        cone_type: The type of cone (left/right)\n    Returns:\n        A cost for each configuration\n    """\n\n    factors: FloatArray = np.array([4.0, 10.0, 0.0, 20.0, 3.0])\n\n    angle_cost = calc_angle_cost_for_configuration(points, configurations, cone_type)\n\n    line_segment_intersection_cost = calc_line_segment_intersection_cost(\n        points, configurations\n    )\n\n    threshold_distance = 5  # maximum allowed distance between cones is 5 meters\n    residual_distance_cost = calc_distance_cost(\n        points, configurations, threshold_distance\n    )\n\n    number_of_cones_cost = calc_number_of_cones_cost(configurations)\n\n    initial_direction_cost = calc_initial_direction_cost(\n        points, configurations, vehicle_direction\n    )\n    final_costs = (\n        np.column_stack(\n            [\n                angle_cost,\n                line_segment_intersection_cost,\n                residual_distance_cost,\n                number_of_cones_cost,\n                initial_direction_cost,\n            ]\n        )\n        * factors\n    )\n\n    if return_individual_costs:\n        return final_costs\n\n    return final_costs.sum(axis=-1)\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/cone_distance_cost.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: Calculate the cost of configurations according to the cost of the distance\nbetween cones\nProject: FaSTTUBe Chabo Pathing\n"""\nimport numpy as np\nfrom chabo_common.utils.math_utils import trace_distance_to_next\n\nfrom chabo_pathing.types import FloatArray, IntArray\n\n\ndef calc_distance_cost(\n    points: FloatArray, configurations: IntArray, threshold_distance: float\n) -> FloatArray:\n    """\n    Calculate the sum of the residual distances between consecutive cones. The residual\n    distance is defined as the distance between two cones that is over\n    `threshold_distance`. If two cones have a distance that is less than\n    `threshold_distance`, then the residual distance is 0.\n    """\n    points_in_configurations = points[configurations]\n    distances_to_next = trace_distance_to_next(points_in_configurations)\n\n    distances_to_next_filtered = distances_to_next * (configurations != -1)[:, 1:]\n\n    residual_distances = np.maximum(0, distances_to_next_filtered - threshold_distance)\n    sum_of_residual_distances_for_configurations: FloatArray = residual_distances.sum(\n        axis=-1\n    )\n    return sum_of_residual_distances_for_configurations\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/line_segment_intersection.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: A module for finding line segment intersections. It can be used as part\nof the cost function of the sorting algorithm.\n\nProject: FaSTTUBe Chabo Pathing\n"""\nfrom typing import TYPE_CHECKING, Any, cast\n\nimport numpy as np\nfrom chabo_common.utils.math_utils import my_njit\n\nfrom chabo_pathing.types import BoolArray, FloatArray, IntArray\n\nif not TYPE_CHECKING:\n\n    @my_njit\n    def cast(  # pylint: disable=function-redefined\n        type_: Any, value_: Any  # pylint: disable=unused-argument\n    ) -> Any:\n        "Dummy numba jit function"\n        return value_\n\n\n@my_njit\ndef _make_segments_homogeneous(\n    segment_a_start: FloatArray,\n    segment_a_end: FloatArray,\n    segment_b_start: FloatArray,\n    segment_b_end: FloatArray,\n) -> FloatArray:\n    homogenenous = np.ones((4, 3))\n    homogenenous[0, :2] = segment_a_start\n    homogenenous[1, :2] = segment_a_end\n    homogenenous[2, :2] = segment_b_start\n    homogenenous[3, :2] = segment_b_end\n\n    return homogenenous\n\n\n@my_njit\ndef _handle_line_segment_intersection_parallel_case(\n    segment_a_start: FloatArray,\n    segment_a_end: FloatArray,\n    segment_b_start: FloatArray,\n    segment_b_end: FloatArray,\n    epsilon: float,\n) -> bool:\n    # lines are parallel only one slope calculation necessary\n    difference: FloatArray = segment_a_end - segment_a_start\n\n    if difference[0] < epsilon:\n        # parallel vertical line segments\n        # overlap only possible if x element is the same for both line segments\n        maybe_overlap = np.abs(segment_a_start[0] - segment_b_start[0]) < epsilon\n        slope = np.inf\n    else:\n        slope = difference[1] / difference[0]\n        # parallel non vertical lines\n        # overlap possible only if intercept of lines is the same\n        intercept_a = segment_a_start[1] - slope * segment_a_start[0]\n        intercept_b = segment_b_start[1] - slope * segment_b_start[0]\n        maybe_overlap = np.abs(intercept_a - intercept_b) < epsilon\n\n    if not maybe_overlap:\n        # parallel lines, different intercept, 100% no intersection\n        return False\n\n    axis_to_use = 1 if slope > 1 else 0\n\n    if segment_a_start[axis_to_use] < segment_b_start[axis_to_use]:\n        left_segment_end_scalar = segment_a_end[axis_to_use]\n        right_segment_start_scalar = min(\n            segment_b_start[axis_to_use], segment_b_end[axis_to_use]\n        )\n    else:\n        left_segment_end_scalar = segment_b_end[axis_to_use]\n        right_segment_start_scalar = min(\n            segment_a_start[axis_to_use], segment_a_end[axis_to_use]\n        )\n\n    return_value = cast(\n        bool,\n        left_segment_end_scalar >= right_segment_start_scalar,\n    )\n    return return_value\n\n\n_DEFAULT_EPSILON = 1e-6\n\n\n@my_njit\ndef lines_segments_intersect_indicator(\n    segment_a_start: FloatArray,\n    segment_a_end: FloatArray,\n    segment_b_start: FloatArray,\n    segment_b_end: FloatArray,\n    epsilon: float = _DEFAULT_EPSILON,\n) -> bool:\n    """\n    Given the start- and endpoint of two 2d-line segments indicate if the two line segments\n    intersect.\n\n    Args:\n        segment_a_start: The start point of the first line segment.\n        segment_a_end: The end point of the first line segment.\n        segment_b_start: The start point of the second line segment.\n        segment_b_end: The end point of the second line segment.\n        epsilon: The epsilon value to use when comparing floating point values.\n\n    Returns:\n        A boolean indicating if the two line segments intersect.\n    """\n    # Adapted from https://stackoverflow.com/a/42727584\n    homogeneous = _make_segments_homogeneous(\n        segment_a_start, segment_a_end, segment_b_start, segment_b_end\n    )\n\n    line_a = np.cross(homogeneous[0], homogeneous[1])  # get first line\n    line_b = np.cross(homogeneous[2], homogeneous[3])  # get second line\n    inter_x, inter_y, inter_z = np.cross(line_a, line_b)  # point of intersection\n\n    # lines are parallel <=> z is zero\n    # np.allclose not allowed in nopython mode\n    if np.abs(inter_z) < epsilon:\n        return _handle_line_segment_intersection_parallel_case(\n            segment_a_start, segment_a_end, segment_b_start, segment_b_end, epsilon\n        )\n\n    # find intersection point\n    intersection_x, intersection_y = np.array([inter_x / inter_z, inter_y / inter_z])\n\n    # bounding boxes\n    segment_a_left, segment_a_right = np.sort(homogeneous[:2, 0])\n    segment_b_left, segment_b_right = np.sort(homogeneous[2:, 0])\n    segment_a_bottom, segment_a_top = np.sort(homogeneous[:2, 1])\n    segment_b_bottom, segment_b_top = np.sort(homogeneous[2:, 1])\n\n    # check that intersection point is in both bounding boxes\n    # check with a bit of epsilon for numerical stability\n\n    return_value = (\n        (segment_a_left - epsilon <= intersection_x <= segment_a_right + epsilon)\n        and (segment_b_left - epsilon <= intersection_x <= segment_b_right + epsilon)\n        and (segment_a_bottom - epsilon <= intersection_y <= segment_a_top + epsilon)\n        and (segment_b_bottom - epsilon <= intersection_y <= segment_b_top + epsilon)\n    )\n\n    return bool(return_value)\n\n\n@my_njit\ndef batch_lines_segments_intersect_indicator(\n    segments_a_start: FloatArray,\n    segments_a_end: FloatArray,\n    segments_b_start: FloatArray,\n    segments_b_end: FloatArray,\n) -> FloatArray:\n    """\n    Run the lines_segments_intersect_indicator function on a batch of line segments.\n    The shape of all inputs should be the same. No broadcasting is performed.\n\n    Args:\n        segments_a_start: The start points of the first line segments.\n        segments_a_end: The end points of the first line segments.\n        segments_b_start: The start points of the second line segments.\n        segments_b_end: The end points of the second line segments.\n\n    Returns:\n        A boolean array indicating if the two line segments intersect.\n    """\n    assert segments_a_start.shape[-1] == 2\n    assert segments_a_start.shape == segments_a_end.shape\n    assert segments_a_start.shape == segments_b_start.shape\n    assert segments_a_start.shape == segments_b_end.shape\n\n    segment_a_start_flat = segments_a_start.reshape(-1, 2)\n    segment_a_end_flat = segments_a_end.reshape(-1, 2)\n    segment_b_start_flat = segments_b_start.reshape(-1, 2)\n    segment_b_end_flat = segments_b_end.reshape(-1, 2)\n\n    n_values_flat = len(segment_a_start_flat)\n\n    out_flat: FloatArray = np.zeros(n_values_flat)\n\n    for i in range(n_values_flat):\n        segment_a_start_single = segment_a_start_flat[i]\n        segment_a_end_single = segment_a_end_flat[i]\n        segment_b_start_single = segment_b_start_flat[i]\n        segment_b_end_single = segment_b_end_flat[i]\n\n        out_flat[i] = lines_segments_intersect_indicator(\n            segment_a_start_single,\n            segment_a_end_single,\n            segment_b_start_single,\n            segment_b_end_single,\n        )\n\n    out_shape = segments_a_start.shape[:-1]\n    out = out_flat.reshape(out_shape)\n\n    return out\n\n\n@my_njit\ndef pairwise_segment_intersection(\n    segment_starts: FloatArray,\n    segment_ends: FloatArray,\n    intersect_with_self: bool = False,\n) -> BoolArray:\n    """\n    For a set of line segments, find the pairwise intersections.\n\n    Args:\n        segment_starts: The start points of the line segments.\n        segment_ends: The end points of the line segments.\n        intersect_with_self: Whether a line segment is considered to intersect with\n            itself.\n\n    Returns:\n        A square boolean array of shape (n_segments, n_segments) where the\n        intersection is True if the two line segments intersect.\n    """\n    assert len(segment_starts) == len(segment_ends)\n\n    number_of_segments = len(segment_starts)\n\n    # [0,1,2] (example)\n    indices = np.arange(number_of_segments)\n\n    # [0,0,0,1,1,1,2,2,2]\n    indices_first = np.repeat(indices, number_of_segments)\n    # [0,1,2,0,1,2,0,1,2] (tile is not allowed in njit)\n    indices_second: IntArray = (\n        indices_first.reshape(number_of_segments, -1).T.copy().reshape(-1)\n    )\n\n    # keep lower triangle\n    # intersect_with_self just turns the main diagonal on (done later)\n    # (we don\'t perform any computation on self)\n    # [False, True, True, False, False, True, False, False, False]\n    mask_indices_to_keep: BoolArray = indices_first < indices_second\n    # [0, 0, 1]\n    indices_first_keep = indices_first[mask_indices_to_keep]\n    # [1, 2, 2]\n    indices_second_keep = indices_second[mask_indices_to_keep]\n\n    first_starts = segment_starts[indices_first_keep]\n    first_ends = segment_ends[indices_first_keep]\n    second_starts = segment_starts[indices_second_keep]\n    second_ends = segment_ends[indices_second_keep]\n\n    indicator_overlap = batch_lines_segments_intersect_indicator(\n        first_starts, first_ends, second_starts, second_ends\n    )\n\n    if intersect_with_self:\n        indicator_matrix = np.eye(number_of_segments, dtype=np.bool_)\n    else:\n        indicator_matrix = np.zeros(\n            (number_of_segments, number_of_segments), dtype=np.bool_\n        )\n\n    # cannot used advanced indexing twice with nopython\n    # so we have to do it manually\n    for index_first_single, index_second_single, indicator_overlap_single in zip(\n        indices_first_keep, indices_second_keep, indicator_overlap\n    ):\n\n        indicator_matrix[\n            index_first_single, index_second_single\n        ] = indicator_overlap_single\n        indicator_matrix[\n            index_second_single, index_first_single\n        ] = indicator_overlap_single\n\n    return indicator_matrix\n\n\n@my_njit\ndef number_of_intersections(intersection_matrix: BoolArray) -> int:\n    """\n    Given sorted 2d-points find the number of intersections between the segments.\n\n    "Sorted" means that the line segments are extracted in the order that the points\n    are in the array.\n\n    Args:\n        intersection_matrix: The square boolean array of shape (n_segments, n_segments)\n            where the intersection is True if the two line segments intersect.\n    Returns:\n        The number of intersections between the segments.\n    """\n\n    # we only count the lower triangle, otherwise we double count intersections not\n    # on the diagonal because the matrix is symmetric\n    lower_triangle_matrix = np.tril(intersection_matrix)  # type: ignore\n    return np.count_nonzero(lower_triangle_matrix)\n\n\n@my_njit\ndef trace_intersections(\n    points: FloatArray,\n    intersect_with_consecutive_segments: bool = False,\n    intersect_with_self: bool = False,\n) -> BoolArray:\n    """\n    Given sorted 2d-points find the intersections between the segments.\n\n    "Sorted" means that the line segments are extracted in the order that the points\n    are in the array.\n\n    Args:\n        points: The points to trace. Shape is (n_points, 2).\n        intersect_with_consecutive_segments: Whether to include the pairwise\n            intersections with consecutive segments. By definition consecutive segments\n            intersect because they share a point.\n        intersect_with_self: Whether a line segment is considered to intersect with\n            itself.\n\n    Returns:\n        A square boolean array of shape (n_points - 1, n_points - 1) where the elements\n        indicate if the two line segments intersect.\n    """\n    segment_starts = points[:-1]\n    segment_ends = points[1:]\n\n    intersections = pairwise_segment_intersection(\n        segment_starts,\n        segment_ends,\n        intersect_with_self=intersect_with_self,\n    )\n    if not intersect_with_consecutive_segments:\n        # set the diagonals next to the main diagonal (see np.eye with k=1,-1)\n        # to be false\n        for i in range(len(segment_starts)):\n            next_diagonal_index = i + 1\n            intersections[i, next_diagonal_index] = False\n            intersections[next_diagonal_index, i] = False\n\n    return intersections\n\n\n@my_njit\ndef number_of_intersections_in_trace(\n    points: FloatArray,\n    intersect_with_consecutive_segments: bool = False,\n    intersect_with_self: bool = False,\n) -> int:\n    """\n    Given sorted 2d-points find the number of intersections between the segments.\n\n    "Sorted" means that the line segments are extracted in the order that the points\n    are in the array.\n\n    Args:\n        points: The points to trace. Shape is (n_points, 2).\n        intersect_with_consecutive_segments: Whether to include the pairwise\n            intersections with consecutive segments. By definition consecutive segments\n            intersect because they share a point.\n        intersect_with_self: Whether a line segment is considered to intersect with\n            itself.\n\n    Returns:\n        The number of intersections between the segments.\n    """\n    intersections = trace_intersections(\n        points,\n        intersect_with_consecutive_segments=intersect_with_consecutive_segments,\n        intersect_with_self=intersect_with_self,\n    )\n    return number_of_intersections(intersections)\n\n\n@my_njit\ndef number_of_intersections_in_configurations(\n    points: FloatArray, configurations: IntArray\n) -> IntArray:\n    """\n    Calculate the number of intersections for a given set of configurations of 2d\n    points.\n\n    Args:\n        points: The 2d point cloud. Shape is (n_points, 2).\n        configurations: The configurations of the points. Shape is\n            (n_configurations, n_points).\n\n    Returns:\n        The number of intersections for each configuration. Shape is\n        (n_configurations,).\n    """\n    number_of_configurations = len(configurations)\n\n    result_array = np.zeros(number_of_configurations, dtype=np.int64)\n\n    for i in range(number_of_configurations):\n        configuration = configurations[i]\n        configuration_filtered = configuration[configuration != -1]\n        points_configuration = points[configuration_filtered]\n        number_of_intersections_for_configuration = number_of_intersections_in_trace(\n            points_configuration\n        )\n        result_array[i] = number_of_intersections_for_configuration\n\n    return result_array\n')
    __stickytape_write_module('chabo_pathing/sorting_cones/trace_sorter/end_configurations.py', b'#!/usr/bin/env python3\n# -*- coding:utf-8 -*-\n"""\nDescription: This File calculates all the possible paths\nProject: FaSTTUBe Chabo Pathing\n"""\nfrom typing import TYPE_CHECKING, Optional, Tuple\n\nimport numpy as np\nfrom chabo_common.constants.cone_types import ConeTypes\nfrom chabo_common.utils.math_utils import my_in1d, my_njit\n\nfrom chabo_pathing.sorting_cones.trace_sorter.common import NoPathError\nfrom chabo_pathing.sorting_cones.trace_sorter.line_segment_intersection import cast\nfrom chabo_pathing.types import BoolArray, FloatArray, GenericArray, IntArray\n\n\n@my_njit\ndef adjacency_matrix_to_borders_and_targets(\n    adjacency_matrix: IntArray,\n) -> Tuple[IntArray, IntArray]:\n    """\n    Convert an adjacency matrix to two flat arrays, one representing the neighbors of\n    each node and one which indicates the starting index of each node in the neighbors\n    array\n    [\n        [0 1 0]\n        [1 1 1]\n        [1 0 0]\n    ]\n    is converted to\n    neighbors -> [1, 0, 1, 2, 0]\n    borders -> [0, 1, 4, 5]\n    Args:\n        adjacency_matrix: The adjacency matrix to convert\n    Returns:\n        The neighbors and the starting position of each node in the neighbors array\n    """\n    source, neighbors_flat = np.where(adjacency_matrix)\n\n    borders: IntArray = np.zeros((adjacency_matrix.shape[0], 2), dtype=np.int32) - 1\n    borders[0] = [0, 0]\n\n    for index in range(len(neighbors_flat)):\n        source_idx = source[index]\n\n        if borders[source_idx][0] == -1:\n            borders[source_idx][0] = index\n\n        borders[source_idx][1] = index + 1\n\n    # for all the nodes that have no neighbors set their start and end to the\n    # previous node\'s end\n    for i, value in enumerate(borders):\n        if value[0] == -1:\n            previous = borders[i - 1][1]\n            borders[i] = [previous, previous]\n\n    final_borders = np.concatenate((borders[:, 0], borders[-1:, -1]))\n\n    return neighbors_flat, final_borders\n\n\n@my_njit\ndef double_stack_len(stack: GenericArray) -> GenericArray:\n    """\n    Double the capacity of a stack (used in the path search)\n    Args:\n        stack: The stack whose size will be doubled\n    Returns:\n        A copy of the stack with double the capacity\n    """\n    _len = stack.shape[0]\n    new_shape = (_len * 2, *stack.shape[1:])\n    new_buffer = np.full(new_shape, -1, dtype=stack.dtype)\n\n    new_buffer[:_len] = stack\n    return new_buffer\n\n\n@my_njit\ndef resize_stack_if_needed(stack: GenericArray, stack_pointer: int) -> GenericArray:\n    """\n    Given a stack and its current pointer resize the stack if adding one more element\n    would result in an index error\n    Args:\n        stack: The stack to potentially resize\n        stack_pointer: The current position (filled size) of the stack\n    Returns:\n        np.ndarray: The stack, if resized then a copy is returned\n    """\n    if stack_pointer >= stack.shape[0]:\n        stack = double_stack_len(stack)\n\n    return stack\n\n\n# for numba\nFLOAT = float if TYPE_CHECKING else np.float32\n\n\n@my_njit\ndef neighbor_bool_mask_can_be_added_to_attempt(\n    trace: FloatArray,\n    cone_type: ConeTypes,\n    current_attempt: IntArray,\n    position_in_stack: int,\n    neighbors: IntArray,\n    threshold_directional_angle: float,\n    threshold_absolute_angle: float,\n) -> BoolArray:\n    # neighbor can be added if not in current attempt\n    can_be_added = ~my_in1d(neighbors, current_attempt[: position_in_stack + 1])\n    for i in range(len(can_be_added)):\n        if not can_be_added[i]:\n            continue\n\n        # calculate angle between second to last to last vector in attempt\n        # and the vector between the last node and the candidate neighbor\n        # add to current attempt only if the angle between the current last\n        # vector and the potential new last vector is less than a specific\n        # threshold. there are two thresholds, one is the maximum angle in a specific direction\n        # for blue cones that is counter-clockwise and for yellow cones that is clockwise\n        # the second threshold is an absolute angle between the two vectors.\n        if position_in_stack >= 1:\n            second_to_last_in_attempt = trace[current_attempt[position_in_stack - 1]]\n            last_in_attempt = trace[current_attempt[position_in_stack]]\n            candidate_neighbor = trace[neighbors[i]]\n            second_to_last_to_last = last_in_attempt - second_to_last_in_attempt\n            last_to_candidate = candidate_neighbor - last_in_attempt\n            angle_1 = cast(\n                FLOAT,\n                np.arctan2(second_to_last_to_last[1], second_to_last_to_last[0]),\n            )\n            angle_2 = cast(\n                FLOAT,\n                np.arctan2(last_to_candidate[1], last_to_candidate[0]),\n            )\n            # order is important here\n            difference = angle_difference(angle_2, angle_1)\n            len_last_to_candidate = np.linalg.norm(last_to_candidate)\n\n            if np.abs(difference) > threshold_absolute_angle:\n                can_be_added[i] = False\n            elif cone_type == ConeTypes.LEFT:\n                can_be_added[i] = (\n                    difference < threshold_directional_angle\n                    or len_last_to_candidate < 4.5\n                )\n            elif cone_type == ConeTypes.RIGHT:\n                can_be_added[i] = (\n                    difference > -threshold_directional_angle\n                    or len_last_to_candidate < 4.5\n                )\n            else:\n                raise AssertionError("Unreachable code")\n    return can_be_added\n\n\n@my_njit\ndef angle_difference(angle1: FloatArray, angle2: FloatArray) -> FloatArray:\n    """\n    Calculate the difference between two angles. The range of the difference is [-pi, pi].\n    The order of the angles *is* important.\n\n    Args:\n        angle1: First angle.\n        angle2: Second angle.\n\n    Returns:\n        The difference between the two angles.\n    """\n    return cast(FloatArray, (angle1 - angle2 + 3 * np.pi) % (2 * np.pi) - np.pi)  # type: ignore\n\n\n@my_njit\ndef _impl_find_all_end_configurations(\n    trace: FloatArray,\n    cone_type: ConeTypes,\n    start_idx: int,\n    adjacency_neighbors: IntArray,\n    adjacency_borders: IntArray,\n    target_length: int,\n    threshold_directional_angle: float,\n    threshold_absolute_angle: float,\n    first_k_indices_must_be: IntArray,\n    store_all_end_configurations: bool,\n) -> tuple[IntArray, Optional[tuple[IntArray, BoolArray]]]:\n    """\n    Finds all the possible paths up to length target length. If a path\n    Args:\n        start_idx: The index of the starting node\n        adjacency_neighbors: The indices of the sink for each edge\n        adjacency_borders: The start position of the indices of each node\n        target_length: The length of the path that the search is searching for\n    Returns:\n        A 2d array of configurations (indices) that define all the valid paths\n    """\n    end_configurations: IntArray = np.full((10, target_length), -1, dtype=np.int32)\n    end_configurations_pointer = 0\n    stack: IntArray = np.zeros((10, 2), dtype=np.int32)\n    stack_end_pointer = 0\n    current_attempt: IntArray = np.zeros(target_length, dtype=np.int32) - 1\n    if len(first_k_indices_must_be) > 0:\n        pos = len(first_k_indices_must_be) - 1\n        current_attempt[:pos] = first_k_indices_must_be[:-1]\n        stack[0] = [first_k_indices_must_be[-1], pos]\n    else:\n        stack[0] = [start_idx, 0]\n\n    if store_all_end_configurations:\n        all_configurations_counter = 0\n        all_configurations = end_configurations.copy()\n        configuration_is_end = np.zeros(end_configurations.shape[0], dtype=np.bool_)\n\n    while stack_end_pointer >= 0:\n\n        # pop the index and the position from the stack\n        next_idx, position_in_stack = stack[stack_end_pointer]\n        stack_end_pointer -= 1\n\n        # add the node to the current path\n        current_attempt[position_in_stack] = next_idx\n        current_attempt[position_in_stack + 1 :] = -1\n\n        # get the neighbors of the last node in the attempt\n        neighbors = adjacency_neighbors[\n            adjacency_borders[next_idx] : adjacency_borders[next_idx + 1]\n        ]\n\n        can_be_added = neighbor_bool_mask_can_be_added_to_attempt(\n            trace,\n            cone_type,\n            current_attempt,\n            position_in_stack,\n            neighbors,\n            threshold_directional_angle,\n            threshold_absolute_angle,\n        )\n\n        has_valid_neighbors = position_in_stack < target_length - 1 and np.any(\n            can_be_added\n        )\n        # check that we haven\'t hit target length and that we have neighbors to add\n        if has_valid_neighbors:\n            for i in range(len(can_be_added)):\n                if not can_be_added[i]:\n                    continue\n\n                stack_end_pointer += 1\n\n                stack = resize_stack_if_needed(stack, stack_end_pointer)\n                stack[stack_end_pointer] = [\n                    neighbors[i],\n                    position_in_stack + 1,\n                ]\n\n        # leaf\n        else:\n            end_configurations = resize_stack_if_needed(\n                end_configurations, end_configurations_pointer\n            )\n\n            end_configurations[end_configurations_pointer:] = current_attempt.copy()\n\n            end_configurations_pointer += 1\n\n        if store_all_end_configurations:\n            all_configurations = resize_stack_if_needed(\n                all_configurations, all_configurations_counter\n            )\n            configuration_is_end = resize_stack_if_needed(\n                configuration_is_end, all_configurations_counter\n            )\n            all_configurations[all_configurations_counter] = current_attempt\n            configuration_is_end[all_configurations_counter] = not has_valid_neighbors\n            all_configurations_counter += 1\n\n    return_value_end_configurations: IntArray = end_configurations[\n        :end_configurations_pointer\n    ]\n\n    mask_end_configurations_with_more_that_two_nodes = (\n        return_value_end_configurations != -1\n    ).sum(axis=1) > 2\n    return_value_end_configurations = return_value_end_configurations[\n        mask_end_configurations_with_more_that_two_nodes\n    ]\n\n    if store_all_end_configurations:\n        all_configurations = all_configurations[:all_configurations_counter]\n        configuration_is_end = configuration_is_end[:all_configurations_counter]\n\n    config_history = None\n    if store_all_end_configurations:\n        config_history = (all_configurations, configuration_is_end)\n\n    return return_value_end_configurations, config_history\n\n\ndef find_all_end_configurations(\n    points: FloatArray,\n    cone_type: ConeTypes,\n    start_idx: int,\n    adjacency_matrix: IntArray,\n    target_length: int,\n    threshold_directional_angle: float,\n    threshold_absolute_angle: float,\n    first_k_indices_must_be: IntArray,\n    store_all_end_configurations: bool,\n) -> tuple[IntArray, Optional[tuple[IntArray, BoolArray]]]:\n    """\n    Finds all the possible paths that include all the reachable nodes from the starting\n    Args:\n        start_idx: The index of the starting node\n        adjacency_matrix: The adjacency matrix indicating which nodes are\n        connected to which\n        target_length: The length of the path that the search is searching for\n    Raises:\n        NoPathError: If no path has been found\n    Returns:\n        A 2d array of configurations (indices) that define a path\n    """\n    # print(locals())\n    neighbors_flat, borders = adjacency_matrix_to_borders_and_targets(adjacency_matrix)\n\n    (\n        end_configurations,\n        all_configurations_and_is_end_configuration_indicator,\n    ) = _impl_find_all_end_configurations(\n        points,\n        cone_type,\n        start_idx,\n        neighbors_flat,\n        borders,\n        target_length,\n        threshold_directional_angle,\n        threshold_absolute_angle,\n        first_k_indices_must_be,\n        store_all_end_configurations,\n    )\n\n    if len(first_k_indices_must_be) > 0 and len(end_configurations) > 0:\n        mask_keep = (\n            end_configurations[:, : len(first_k_indices_must_be)]\n            == first_k_indices_must_be\n        ).all(axis=1)\n        end_configurations = end_configurations[mask_keep]\n\n    if len(end_configurations) == 0:\n        raise NoPathError("Could not create a valid trace using the provided points")\n\n    return end_configurations, all_configurations_and_is_end_configuration_indicator\n')
    __stickytape_write_module('test_animation.py', b'import matplotlib.animation as animation\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport streamlit as st\nimport streamlit.components.v1 as components\n\n\ndef update_line(num, data, line):\n    line.set_data(data[..., :num])\n    return (line,)\n\n\ndef run() -> None:\n    fig = plt.figure()\n\n    # Fixing random state for reproducibility\n    np.random.seed(19680801)\n\n    data = np.random.rand(2, 25)\n    (l,) = plt.plot([], [], "r-")\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n    plt.xlabel("x")\n    plt.title("test")\n    line_ani = animation.FuncAnimation(\n        fig, update_line, 25, fargs=(data, l), interval=200, blit=True\n    )\n\n    st.title("Embed Matplotlib animation in Streamlit")\n    st.markdown("https://matplotlib.org/gallery/animation/basic_example.html")\n    components.html(line_ani.to_jshtml(), height=1000)\n')
    import streamlit as st
    from cone_sorting import run as run_sorting
    from test_animation import run as run_test
    
    
    def run_welcome() -> None:
        st.markdown(
            """
    # Chabo AS
    ## Pathing
    
    Welcome to the Chabo AS Pathing app. The goal of this app is to visualize the algorithms
    that are used for the path planning of the Chabo Autonomous System.
    
    The path planning algorithm is split ito three parts:
    
    - Cone Sorting
    - Cone Matching
    - Path Calculation
    
    In the sidebar of the app you can select the algorithm you want to explore.
    """.strip()
        )
    
    
    STRING_TO_FUNCTION = {
        "Welcome": run_welcome,
        "Sorting": run_sorting,
        "Testing animation": run_test,
    }
    
    with st.sidebar:
        st.markdown("# Chabo AS Pathing")
        page_function = STRING_TO_FUNCTION[st.selectbox("Mode", STRING_TO_FUNCTION)]
    
        st.markdown("---")
        st.session_state.track_configuration = st.selectbox(
            "Configuration", ("Straight", "Simple Corner", "Hairpin")
        )
    
    page_function()
    